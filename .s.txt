Controllers\BaseController.java (503)
```java
/**
 * Abstract base class for all controllers in the BTO application.
 * Provides common dependencies (services, current user, scanner, auth controller),
 * shared utility methods (finding data, checking date overlaps, input validation),
 * and common functionalities like project filtering and display.
 *
 * @author Kai Wang
 */
package Controllers;

import Enums.OfficerRegistrationStatus;
import Enums.FlatType;
import Enums.ApplicationStatus;
import Enums.MaritalStatus;
import Enums.UserRole;

import Models.User;
import Parsers.Dparse;
import Models.Project;
import Models.BTOApplication;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.Applicant;
import Models.OfficerRegistration;
import Models.FlatTypeDetails;

import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Comparator;
import java.util.stream.Collectors;

import Utils.DateUtils;

public abstract class BaseController {
    protected final IUserService userService;
    protected final IProjectService projectService;
    protected final IApplicationService applicationService;
    protected final IOfficerRegistrationService officerRegistrationService;
    protected final User currentUser;
    protected final Scanner scanner;
    protected final AuthController authController;

    protected static String filterLocation = null;
    protected static FlatType filterFlatType = null;

    /**
     * Constructs a new BaseController, initializing shared services and components.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param currentUser                The currently logged-in User object.
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks (like
     *                                   password change).
     */
    public BaseController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            User currentUser, Scanner scanner, AuthController authController) {
        this.userService = userService;
        this.projectService = projectService;
        this.applicationService = applicationService;
        this.officerRegistrationService = officerRegistrationService;
        this.currentUser = currentUser;
        this.scanner = scanner;
        this.authController = authController;
    }

    /**
     * Finds a project by its name using the injected project service.
     *
     * @param name The name of the project to find.
     * @return The Project object if found, null otherwise.
     */
    protected Project findProjectByName(String name) {
        return projectService.findProjectByName(name);
    }

    /**
     * Finds a BTO application based on the applicant's NRIC and project name using
     * the injected application service.
     *
     * @param nric        The applicant's NRIC.
     * @param projectName The project name.
     * @return The BTOApplication object if found, null otherwise.
     */
    protected BTOApplication findApplicationByApplicantAndProject(String nric, String projectName) {
        return applicationService.findApplicationByApplicantAndProject(nric, projectName);
    }

    /**
     * Determines which active project an HDB Officer is currently approved to
     * handle.
     * Checks the officer registration service for an APPROVED registration and
     * verifies
     * that the corresponding project's application period is still active.
     *
     * @param officer The HDBOfficer whose handling project is to be determined.
     * @return The Project object the officer is currently handling and which is
     *         active, or null if none.
     */
    public Project getOfficerHandlingProject(HDBOfficer officer) {
        if (officer == null)
            return null;
        Date today = DateUtils.getCurrentDate();
        OfficerRegistration approvedReg = officerRegistrationService
                .getApprovedRegistrationForOfficer(officer.getNric());

        if (approvedReg != null) {
            Project project = projectService.findProjectByName(approvedReg.getProjectName());
            if (project != null && project.isApplicationPeriodActive(today)) {
                return project;
            }
        }
        return null;
    }

    /**
     * Checks if the application periods of two projects overlap.
     * Handles null projects or dates gracefully (returns false).
     * Overlap occurs if p1's start is not after p2's end AND p1's end is not before
     * p2's start.
     *
     * @param p1 The first project.
     * @param p2 The second project.
     * @return true if the application periods overlap, false otherwise or if data
     *         is invalid.
     */
    protected boolean checkDateOverlap(Project p1, Project p2) {
        if (p1 == null || p2 == null || p1.getApplicationOpeningDate() == null || p1.getApplicationClosingDate() == null
                || p2.getApplicationOpeningDate() == null || p2.getApplicationClosingDate() == null) {
            return false;
        }
        boolean noOverlap = p1.getApplicationOpeningDate().after(p2.getApplicationClosingDate()) ||
                p1.getApplicationClosingDate().before(p2.getApplicationOpeningDate());
        return !noOverlap;
    }

    /**
     * Retrieves a list of projects based on various filtering criteria.
     * Applies internal controller filters (location, flat type) first.
     * Then applies boolean flags to control checks for visibility, application
     * period activity/expiry,
     * eligibility (based on current user), and unit availability.
     * Sorts the final list by project name.
     *
     * @param checkVisibility        If true, only includes projects visible to the
     *                               current user (see
     *                               {@link #isProjectVisibleToCurrentUser(Project)}).
     * @param checkEligibility       If true, only includes projects for which the
     *                               current user is eligible to apply for at least
     *                               one flat type (see
     *                               {@link #canApplyForFlatType(FlatType)}).
     *                               Ignored for Managers.
     * @param checkAvailability      If true, only includes projects where there is
     *                               at least one flat type the user is eligible for
     *                               AND which has available units (> 0). Ignored
     *                               for Managers. Requires checkEligibility to be
     *                               meaningful.
     * @param checkApplicationPeriod If true, only includes projects whose
     *                               application period is currently active.
     * @param checkNotExpired        If true, only includes projects whose
     *                               application period has not yet expired.
     * @return A sorted list of Project objects matching all applied filters.
     */
    protected List<Project> getFilteredProjects(boolean checkVisibility, boolean checkEligibility,
            boolean checkAvailability, boolean checkApplicationPeriod, boolean checkNotExpired) {
        Date currentDate = DateUtils.getCurrentDate();
        List<Project> allProjects = projectService.getAllProjects();

        return allProjects.stream()
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                .filter(p -> !checkVisibility || isProjectVisibleToCurrentUser(p))
                .filter(p -> !checkApplicationPeriod || p.isApplicationPeriodActive(currentDate))
                .filter(p -> !checkNotExpired || !p.isApplicationPeriodExpired(currentDate))
                .filter(p -> {
                    if (!checkEligibility && !checkAvailability)
                        return true;
                    if (currentUser instanceof HDBManager)
                        return true;

                    boolean eligibleForAnyType = p.getFlatTypes().keySet().stream()
                            .anyMatch(flatType -> this.canApplyForFlatType(flatType));
                    if (checkEligibility && !eligibleForAnyType)
                        return false;

                    if (!checkAvailability)
                        return true;

                    boolean eligibleAndAvailableExists = p.getFlatTypes().entrySet().stream()
                            .anyMatch(entry -> {
                                FlatType type = entry.getKey();
                                FlatTypeDetails details = entry.getValue();
                                return canApplyForFlatType(type) && details.getAvailableUnits() > 0;
                            });
                    return eligibleAndAvailableExists;
                })
                .sorted(Comparator.comparing(project -> project.getProjectName()))
                .collect(Collectors.toList());
    }

    /**
     * Determines if a specific project should be visible to the currently logged-in
     * user.
     * - Managers see all projects.
     * - Applicants see projects that are globally visible OR projects they have
     * applied to (and application is not failed/withdrawn).
     * - Officers see projects that are globally visible OR projects they are
     * approved to handle.
     *
     * @param project The project to check visibility for.
     * @return true if the project is visible to the current user, false otherwise.
     */
    protected boolean isProjectVisibleToCurrentUser(Project project) {
        if (currentUser instanceof HDBManager)
            return true;

        boolean appliedToThis = false;
        if (currentUser instanceof Applicant) {
            Applicant appUser = (Applicant) currentUser;
            appliedToThis = project.getProjectName().equals(appUser.getAppliedProjectName()) &&
                    appUser.getApplicationStatus() != null &&
                    appUser.getApplicationStatus() != ApplicationStatus.UNSUCCESSFUL &&
                    appUser.getApplicationStatus() != ApplicationStatus.WITHDRAWN;
        }

        boolean isHandlingOfficer = false;
        if (currentUser instanceof HDBOfficer) {
            isHandlingOfficer = officerRegistrationService.getRegistrationsByOfficer(currentUser.getNric())
                    .stream()
                    .anyMatch(reg -> reg.getProjectName().equals(project.getProjectName()) &&
                            reg.getStatus() == OfficerRegistrationStatus.APPROVED);

        }

        return project.isVisible() || appliedToThis || isHandlingOfficer;
    }

    /**
     * Checks if the currently logged-in user is eligible to apply for a specific
     * flat type based on simplified HDB rules.
     * - Managers cannot apply.
     * - Singles (>= 35) can apply for 2-Room.
     * - Married (>= 21) can apply for 2-Room or 3-Room.
     * (Other statuses like divorced/widowed are not explicitly handled here).
     *
     * @param type The FlatType to check eligibility for.
     * @return true if the current user meets the basic criteria for the flat type,
     *         false otherwise.
     */
    protected boolean canApplyForFlatType(FlatType type) {
        if (currentUser instanceof HDBManager)
            return false;

        if (currentUser.getMaritalStatus() == MaritalStatus.SINGLE) {
            return currentUser.getAge() >= 35 && type == FlatType.TWO_ROOM;
        } else if (currentUser.getMaritalStatus() == MaritalStatus.MARRIED) {
            return currentUser.getAge() >= 21 && (type == FlatType.TWO_ROOM || type == FlatType.THREE_ROOM);
        }
        return false;
    }

    /**
     * Prompts the user to enter or clear filters for project location
     * (neighborhood) and flat type.
     * Updates the internal `filterLocation` and `filterFlatType` fields of the
     * controller instance.
     * These filters are used by
     * {@link #getFilteredProjects(boolean, boolean, boolean, boolean, boolean)}.
     */
    public void applyFilters() {
        System.out.println("\n--- Apply/Clear Filters ---");
        System.out.print("Enter neighborhood to filter by (current: "
                + (filterLocation == null ? "Any" : filterLocation) + ", leave blank to clear): ");
        String loc = scanner.nextLine().trim();
        filterLocation = loc.isEmpty() ? null : loc;

        System.out.print("Enter flat type to filter by (TWO_ROOM, THREE_ROOM, current: "
                + (filterFlatType == null ? "Any" : filterFlatType) + ", leave blank to clear): ");
        String typeStr = scanner.nextLine().trim();
        if (typeStr.isEmpty()) {
            filterFlatType = null;
        } else {
            try {
                FlatType parsedType = FlatType.fromString(typeStr);
                if (parsedType != null) {
                    filterFlatType = parsedType;
                } else {
                    System.out.println("Invalid flat type entered. Filter not changed.");
                }
            } catch (IllegalArgumentException e) {
                System.out.println("Invalid flat type format. Filter not changed.");
            }
        }
        System.out.println(
                "Filters updated. Current filters: Location=" + (filterLocation == null ? "Any" : filterLocation)
                        + ", FlatType=" + (filterFlatType == null ? "Any" : filterFlatType));
    }

    /**
     * Displays a list of projects in a formatted table and prompts the user for
     * common actions (like selection).
     * Shows project details including name, neighborhood, dates, visibility, and
     * flat type information
     * (available/total units, price).
     * For Applicants/Officers, it indicates eligibility ("Ineligible", "No Units")
     * for each flat type.
     * For Managers/Officers, it shows manager NRIC and officer slot usage.
     *
     * @param projectList The list of Project objects to display.
     * @param prompt      A title string to display above the project list (e.g.,
     *                    "Select Project to Edit").
     */
    protected void viewAndSelectProject(List<Project> projectList, String prompt) {
        if (projectList.isEmpty()) {
            System.out.println("No projects match the current criteria.");
            return;
        }

        System.out.println("\n--- " + prompt + " ---");
        System.out.println("Current Filters: Location=" + (filterLocation == null ? "Any" : filterLocation)
                + ", FlatType=" + (filterFlatType == null ? "Any" : filterFlatType));
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");
        System.out.printf("%-3s %-15s %-12s %-10s %-10s %-8s %-25s\n", "#", "Project Name", "Neighborhood", "Open",
                "Close", "Visible", "Flat Types (Available/Total, Price, Eligibility)");
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");

        for (int i = 0; i < projectList.size(); i++) {
            Project p = projectList.get(i);
            System.out.printf("%-3d %-15s %-12s %-10s %-10s %-8s ",
                    i + 1,
                    p.getProjectName(),
                    p.getNeighborhood(),
                    DateUtils.formatDate(p.getApplicationOpeningDate()),
                    DateUtils.formatDate(p.getApplicationClosingDate()),
                    p.isVisible() ? "On" : "Off");

            String flatDetails = p.getFlatTypes().entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .map(entry -> {
                        FlatType type = entry.getKey();
                        FlatTypeDetails details = entry.getValue();
                        String eligibilityMark = "";
                        if (currentUser instanceof Applicant) {
                            if (!canApplyForFlatType(type)) {
                                eligibilityMark = " (Ineligible)";
                            } else if (details.getAvailableUnits() <= 0) {
                                eligibilityMark = " (No Units)";
                            }
                        }
                        return String.format("%s: %d/%d ($%.0f)%s",
                                type.getDisplayName(), details.getAvailableUnits(), details.getTotalUnits(),
                                details.getSellingPrice(), eligibilityMark);
                    })
                    .collect(Collectors.joining(", "));
            System.out.println(flatDetails);

            if (currentUser.getRole() != UserRole.APPLICANT) {
                int approvedCount = p.getApprovedOfficerNrics().size();
                System.out.printf("%-3s %-15s %-12s %-10s %-10s %-8s %-25s\n", "", "", "", "", "", "",
                        "Mgr: " + p.getManagerNric() + ", Officers: " + approvedCount + "/" + p.getMaxOfficerSlots());
            }
            if (i < projectList.size() - 1)
                System.out.println("---");

        }
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");
    }

    /**
     * Prompts the user to select a project by number from a previously displayed
     * list.
     * Handles user input, validates the choice against the list size, and allows
     * cancellation (input 0).
     *
     * @param projectList The list of projects from which the user is selecting.
     * @return The selected Project object, or null if the user cancels, enters
     *         invalid input, or the list is empty/null.
     */
    protected Project selectProjectFromList(List<Project> projectList) {
        if (projectList == null || projectList.isEmpty())
            return null;

        System.out.print("Enter the number of the project (or 0 to cancel): ");
        int choice;
        try {
            choice = Integer.parseInt(scanner.nextLine());
            if (choice == 0) {
                System.out.println("Operation cancelled.");
                return null;
            }
            if (choice >= 1 && choice <= projectList.size()) {
                return projectList.get(choice - 1);
            } else {
                System.out.println("Invalid choice number.");
                return null;
            }
        } catch (NumberFormatException e) {
            System.out.println("Invalid input. Please enter a number.");
            return null;
        }
    }

    /**
     * Prompts the user for integer input within a specified range.
     * Reprompts until valid input is received.
     *
     * @param prompt The message to display to the user.
     * @param min    The minimum allowed integer value (inclusive).
     * @param max    The maximum allowed integer value (inclusive).
     * @return The validated integer input from the user.
     */
    protected int getIntInput(String prompt, int min, int max) {
        int value = -1;
        while (true) {
            System.out.print(prompt);
            String input = scanner.nextLine();
            try {
                value = Integer.parseInt(input);
                if (value >= min && value <= max) {
                    break;
                } else {
                    System.out.println("Input must be between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a whole number.");
            }
        }
        return value;
    }

    /**
     * Prompts the user for double (floating-point) input within a specified range.
     * Reprompts until valid input is received.
     *
     * @param prompt The message to display to the user.
     * @param min    The minimum allowed double value (inclusive).
     * @param max    The maximum allowed double value (inclusive).
     * @return The validated double input from the user.
     */
    protected double getDoubleInput(String prompt, double min, double max) {
        double value = -1.0;
        while (true) {
            System.out.print(prompt);
            String input = scanner.nextLine();
            try {
                value = Double.parseDouble(input);
                if (value >= min && value <= max) {
                    break;
                } else {
                    System.out.println("Input must be between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a number.");
            }
        }
        return value;
    }

    /**
     * Prompts the user for date input in "yyyy-MM-dd" format.
     * Uses {@link Parsers.Dparse} for parsing and validation.
     * Reprompts until a valid date is entered or if blank input is disallowed.
     *
     * @param prompt     The message to display to the user.
     * @param allowBlank If true, allows the user to press Enter to skip input
     *                   (returns null). If false, requires valid date input.
     * @return The validated Date object, or null if blank input is allowed and
     *         entered.
     */
    protected Date getDateInput(String prompt, boolean allowBlank) {
        Date date = null;
        while (true) {
            System.out.print(prompt);
            String input = scanner.nextLine().trim();
            if (input.isEmpty() && allowBlank) {
                return null;
            }
            if (input.isEmpty() && !allowBlank) {
                System.out.println("Input cannot be empty.");
                continue;
            }
            date = Dparse.parseDate(input);
            if (date != null) {
                break;
            }
        }
        return date;
    }
}
```

Controllers\ProjectManagerController.java (480)
```java
/**
 * Controller handling actions performed by an HDB Manager specifically related to
 * BTO project management (Create, Read, Update, Delete - CRUD) and visibility control.
 * Requires an IEnquiryService for cleanup during project deletion.
 * Inherits common functionality from BaseController.
 *
 * @author Kishore Kumar
 */
package Controllers;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.OfficerRegistrationStatus;
import Models.BTOApplication;
import Models.Enquiry;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class ProjectManagerController extends BaseController {

    private final IEnquiryService enquiryService;

    /**
     * Constructor for ProjectManagerController
     *
     * @param userService                user service instance
     * @param projectService             project service instance
     * @param applicationService         application service instance
     * @param officerRegistrationService officer registration service instance
     * @param enquiryService             enquiry service instance (needed for
     *                                   deletion cleanup)
     * @param currentUser                currently logged-in user (must be an
     *                                   HDBManager)
     * @param scanner                    scanner for user input
     * @param authController             authentication controller
     */
    public ProjectManagerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        this.enquiryService = enquiryService;
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("ProjectManagerController requires an HDBManager user.");
        }
    }

    /**
     * Guides the HDB Manager through the process of creating a new BTO project.
     * - Prompts for project name (checks for uniqueness), neighborhood.
     * - Prompts for flat type details (total units, price for 2-Room and 3-Room).
     * Ensures at least one type is added.
     * - Prompts for application opening and closing dates (validates order and
     * checks for overlap with other projects managed by the same manager).
     * - Prompts for the maximum number of HDB officer slots (1-10).
     * - Creates a new Project object (initially visibility off, no approved
     * officers).
     * - Adds the project using the project service and saves it immediately.
     */
    public void createProject() {
        HDBManager manager = (HDBManager) currentUser;

        System.out.println("\n--- Create New BTO Project ---");

        String projectName;
        while (true) {
            System.out.print("Enter Project Name: ");
            projectName = scanner.nextLine().trim();
            if (projectName.isEmpty()) {
                System.out.println("Project name cannot be empty.");
            } else if (projectService.findProjectByName(projectName) != null) {
                System.out.println("Project name already exists. Please choose a unique name.");
            } else {
                break;
            }
        }

        System.out.print("Enter Neighborhood: ");
        String neighborhood = scanner.nextLine().trim();
        if (neighborhood.isEmpty()) {
            System.out.println("Neighborhood cannot be empty. Creation cancelled.");
            return;
        }

        Map<FlatType, FlatTypeDetails> flatTypes = new HashMap<>();
        System.out.println("--- Flat Type Details ---");
        int units2Room = getIntInput("Enter total number of 2-Room units (0 if none): ", 0, 9999);
        if (units2Room > 0) {
            double price2Room = getDoubleInput("Enter selling price for 2-Room units: $", 0, Double.MAX_VALUE);
            flatTypes.put(FlatType.TWO_ROOM, new FlatTypeDetails(units2Room, units2Room, price2Room));
        }
        int units3Room = getIntInput("Enter total number of 3-Room units (0 if none): ", 0, 9999);
        if (units3Room > 0) {
            double price3Room = getDoubleInput("Enter selling price for 3-Room units: $", 0, Double.MAX_VALUE);
            flatTypes.put(FlatType.THREE_ROOM, new FlatTypeDetails(units3Room, units3Room, price3Room));
        }

        if (flatTypes.isEmpty()) {
            System.out.println(
                    "Error: Project must have at least one type of flat (2-Room or 3-Room). Creation cancelled.");
            return;
        }

        Date openingDate;
        Date closingDate;
        while (true) {
            openingDate = getDateInput("Enter Application Opening Date (yyyy-MM-dd): ", false);
            closingDate = getDateInput("Enter Application Closing Date (yyyy-MM-dd): ", false);

            if (openingDate == null || closingDate == null) {
                System.out.println("Dates cannot be empty. Please re-enter.");
                continue;
            }
            if (closingDate.before(openingDate)) {
                System.out.println("Closing date cannot be before opening date. Please re-enter.");
                continue;
            }

            Project proposedProjectDates = new Project("__temp__", "__temp__", flatTypes, openingDate, closingDate,
                    manager.getNric(), 0, null, true);
            boolean overlapsWithActive = projectService.getProjectsManagedBy(manager.getNric())
                    .stream()
                    .anyMatch(existingProject -> checkDateOverlap(proposedProjectDates, existingProject));

            if (overlapsWithActive) {
                System.out.println("Error: The specified application period overlaps with another project you manage.");
                System.out.println(
                        "Please enter different dates or manage the visibility/dates of the existing project.");
            } else {
                break;
            }
        }

        int maxOfficers = getIntInput("Enter Maximum HDB Officer Slots (1-10): ", 1, 10);

        Project newProject = new Project(projectName, neighborhood, flatTypes, openingDate, closingDate,
                manager.getNric(), maxOfficers, new ArrayList<>(), false);

        projectService.addProject(newProject);
        System.out.println("Project '" + projectName + "' created successfully. Visibility is currently OFF.");
        projectService.saveProjects(projectService.getAllProjects());
    }

    /**
     * Allows the HDB Manager to edit details of projects they manage.
     * - Displays a list of managed projects for selection.
     * - Allows editing of:
     * - Neighborhood.
     * - Selling prices for existing flat types (cannot change types or total units
     * easily).
     * - Application opening and closing dates (validates order and checks for
     * overlap with *other* managed projects).
     * - Maximum officer slots (ensures new max is not less than current approved
     * count and within 1-10 range).
     * - Updates the Project object directly or via setters.
     * - Saves all projects after the edit attempt.
     */
    public void editProject() {
        System.out.println("\n--- Edit BTO Project ---");
        List<Project> myProjects = getManagedProjects(false);
        if (myProjects.isEmpty()) {
            return;
        }

        viewAndSelectProject(myProjects, "Select Project to Edit");
        Project projectToEdit = selectProjectFromList(myProjects);
        if (projectToEdit == null)
            return;

        System.out
                .println("Editing Project: " + projectToEdit.getProjectName() + " (Leave blank to keep current value)");

        System.out.print("Enter new Neighborhood [" + projectToEdit.getNeighborhood() + "]: ");
        String newNeighborhood = scanner.nextLine().trim();
        if (!newNeighborhood.isEmpty()) {
            projectToEdit.setNeighborhood(newNeighborhood);
        }

        Map<FlatType, FlatTypeDetails> existingFlatTypesView = projectToEdit.getFlatTypes();

        for (FlatType type : FlatType.values()) {
            if (existingFlatTypesView.containsKey(type)) {
                FlatTypeDetails currentDetails = projectToEdit.getMutableFlatTypeDetails(type);
                if (currentDetails != null) {
                    System.out.println("--- Edit " + type.getDisplayName() + " ---");
                    System.out
                            .print("Enter new selling price [" + String.format("%.2f", currentDetails.getSellingPrice())
                                    + "] (leave blank to keep): $");
                    String priceInput = scanner.nextLine().trim();
                    if (!priceInput.isEmpty()) {
                        try {
                            double newPrice = Double.parseDouble(priceInput);
                            if (newPrice >= 0) {
                                currentDetails.setSellingPrice(newPrice);
                            } else {
                                System.out.println("Price cannot be negative. Keeping original price.");
                            }
                        } catch (NumberFormatException e) {
                            System.out.println("Invalid price format. Keeping original price.");
                        }
                    }
                }
            }
        }

        Date originalOpening = projectToEdit.getApplicationOpeningDate();
        Date originalClosing = projectToEdit.getApplicationClosingDate();
        Date newOpeningDate = getDateInput("Enter new Opening Date (yyyy-MM-dd) ["
                + DateUtils.formatDate(originalOpening) + "] (leave blank to keep): ", true);
        Date newClosingDate = getDateInput("Enter new Closing Date (yyyy-MM-dd) ["
                + DateUtils.formatDate(originalClosing) + "] (leave blank to keep): ", true);

        Date finalOpening = (newOpeningDate != null) ? newOpeningDate : originalOpening;
        Date finalClosing = (newClosingDate != null) ? newClosingDate : originalClosing;

        boolean datesChanged = (newOpeningDate != null || newClosingDate != null);
        boolean datesValid = true;

        if (finalClosing.before(finalOpening)) {
            System.out.println("Error: Closing date cannot be before opening date. Dates not updated.");
            datesValid = false;
        }

        if (datesChanged && datesValid) {
            Project proposedProjectDates = new Project(
                    projectToEdit.getProjectName(), projectToEdit.getNeighborhood(), projectToEdit.getFlatTypes(),
                    finalOpening, finalClosing, projectToEdit.getManagerNric(), projectToEdit.getMaxOfficerSlots(),
                    projectToEdit.getApprovedOfficerNrics(), projectToEdit.isVisible());

            boolean overlapsWithOther = projectService.getProjectsManagedBy(currentUser.getNric())
                    .stream()
                    .filter(p -> !p.getProjectName().equals(projectToEdit.getProjectName()))
                    .anyMatch(otherProject -> checkDateOverlap(proposedProjectDates, otherProject));

            if (overlapsWithOther) {
                System.out.println(
                        "Error: The new application period overlaps with another project you manage. Dates not updated.");
                datesValid = false;
            }
        }

        if (datesValid) {
            if (newOpeningDate != null)
                projectToEdit.setApplicationOpeningDate(newOpeningDate);
            if (newClosingDate != null)
                projectToEdit.setApplicationClosingDate(newClosingDate);
            if (datesChanged)
                System.out.println("Application dates updated.");
        }

        int currentMaxSlots = projectToEdit.getMaxOfficerSlots();
        int currentApprovedCount = projectToEdit.getApprovedOfficerNrics().size();
        int minSlots = currentApprovedCount;
        System.out.print("Enter new Max Officer Slots [" + currentMaxSlots + "] (min " + minSlots
                + ", max 10, leave blank to keep): ");
        String slotsInput = scanner.nextLine().trim();
        if (!slotsInput.isEmpty()) {
            try {
                int newMaxSlots = Integer.parseInt(slotsInput);
                projectToEdit.setMaxOfficerSlots(newMaxSlots);
            } catch (NumberFormatException e) {
                System.out.println("Invalid number format. Max slots not changed.");
            }
        }

        System.out.println("Project details update attempt complete.");
        projectService.saveProjects(projectService.getAllProjects());
    }

    /**
     * Allows the HDB Manager to delete a project they manage.
     * - Displays a list of managed projects for selection.
     * - Performs checks to prevent deletion if the project has active associations:
     * - Active BTO applications (Pending, Successful, Booked, PendingWithdrawal).
     * - Active Officer registrations (Pending, Approved).
     * - If no active associations exist, prompts for confirmation.
     * - If confirmed:
     * - Removes the project using the project service.
     * - Removes all associated BTO applications using the application service.
     * - Removes all associated officer registrations using the officer registration
     * service.
     * - Removes all associated enquiries using the enquiry service.
     * - Saves changes after each removal step.
     */
    public void deleteProject() {
        System.out.println("\n--- Delete BTO Project ---");
        List<Project> myProjects = getManagedProjects(false);
        if (myProjects.isEmpty())
            return;

        viewAndSelectProject(myProjects, "Select Project to Delete");
        Project projectToDelete = selectProjectFromList(myProjects);
        if (projectToDelete == null)
            return;

        boolean hasActiveApplications = applicationService.getApplicationsByProject(projectToDelete.getProjectName())
                .stream()
                .anyMatch(app -> app.getStatus() == ApplicationStatus.PENDING ||
                        app.getStatus() == ApplicationStatus.SUCCESSFUL ||
                        app.getStatus() == ApplicationStatus.BOOKED ||
                        app.getStatus() == ApplicationStatus.PENDING_WITHDRAWAL);

        boolean hasActiveRegistrations = officerRegistrationService
                .getRegistrationsByProject(projectToDelete.getProjectName())
                .stream()
                .anyMatch(reg -> reg.getStatus() == OfficerRegistrationStatus.PENDING ||
                        reg.getStatus() == OfficerRegistrationStatus.APPROVED);

        if (hasActiveApplications || hasActiveRegistrations) {
            System.out.println("Error: Cannot delete project '" + projectToDelete.getProjectName() + "'.");
            if (hasActiveApplications)
                System.out.println("- It has active BTO applications (Pending/Successful/Booked/PendingWithdrawal).");
            if (hasActiveRegistrations)
                System.out.println("- It has active Officer registrations (Pending/Approved).");
            System.out.println(
                    "Resolve these associations (e.g., reject applications/registrations, wait for booking/withdrawal) before deleting.");
            return;
        }

        System.out.print("Are you sure you want to permanently delete project '" + projectToDelete.getProjectName()
                + "'? This will also remove associated historical applications, registrations, and enquiries. (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            String deletedProjectName = projectToDelete.getProjectName();

            if (projectService.removeProject(projectToDelete)) {
                System.out.println("Project '" + deletedProjectName + "' deleted successfully.");
                projectService.saveProjects(projectService.getAllProjects());

                List<String> appIdsToRemove = applicationService.getApplicationsByProject(deletedProjectName)
                        .stream()
                        .map((BTOApplication app) -> app.getApplicationId())
                        .collect(Collectors.toList());
                int removedAppCount = 0;
                for (String appId : appIdsToRemove) {
                    if (applicationService.removeApplication(appId)) {
                        removedAppCount++;
                    }
                }
                if (removedAppCount > 0) {
                    System.out.println("Removed " + removedAppCount + " associated applications.");
                    applicationService.saveApplications(applicationService.getAllApplications());
                }

                List<String> regIdsToRemove = officerRegistrationService.getRegistrationsByProject(deletedProjectName)
                        .stream()
                        .map((OfficerRegistration oR) -> oR.getRegistrationId())
                        .collect(Collectors.toList());
                int removedRegCount = 0;
                for (String regId : regIdsToRemove) {
                    if (officerRegistrationService.removeRegistration(regId)) {
                        removedRegCount++;
                    }
                }
                if (removedRegCount > 0) {
                    System.out.println("Removed " + removedRegCount + " associated officer registrations.");
                    officerRegistrationService
                            .saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
                }

                List<String> enqIdsToRemove = enquiryService.getEnquiriesByProject(deletedProjectName)
                        .stream()
                        .map((Enquiry e) -> e.getEnquiryId())
                        .collect(Collectors.toList());
                int removedEnqCount = 0;
                for (String enqId : enqIdsToRemove) {
                    if (enquiryService.removeEnquiry(enqId)) {
                        removedEnqCount++;
                    }
                }
                if (removedEnqCount > 0) {
                    System.out.println("Removed " + removedEnqCount + " associated enquiries.");
                    enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
                }

            } else {
                System.err.println("Error: Failed to remove project from service layer.");
            }
        } else {
            System.out.println("Deletion cancelled.");
        }
    }

    /**
     * Allows the HDB Manager to toggle the visibility status (On/Off) of a project
     * they manage.
     * - Displays a list of managed projects for selection.
     * - Toggles the `visibility` flag on the selected Project object.
     * - Saves all projects after the change.
     */
    public void toggleProjectVisibility() {
        System.out.println("\n--- Toggle Project Visibility ---");
        List<Project> myProjects = getManagedProjects(false);
        if (myProjects.isEmpty())
            return;

        viewAndSelectProject(myProjects, "Select Project to Toggle Visibility");
        Project projectToToggle = selectProjectFromList(myProjects);

        if (projectToToggle != null) {
            boolean currentVisibility = projectToToggle.isVisible();
            projectToToggle.setVisibility(!currentVisibility);
            System.out.println("Project '" + projectToToggle.getProjectName() + "' visibility toggled to "
                    + (projectToToggle.isVisible() ? "ON" : "OFF") + ".");
            projectService.saveProjects(projectService.getAllProjects());
        }
    }

    /**
     * Displays all BTO projects in the system from a manager's perspective.
     * This view ignores visibility, eligibility, availability, and application
     * period checks,
     * showing all projects regardless of their status or the manager's filters.
     * Uses the standard project display format.
     */
    public void viewAllProjects() {
        System.out.println("\n--- View All Projects (Manager View) ---");
        List<Project> displayProjects = getFilteredProjects(false, false, false, false, false);
        viewAndSelectProject(displayProjects, "All BTO Projects (Manager View)");
    }

    /**
     * Displays only the projects managed by the currently logged-in HDB Manager.
     * Applies the manager's currently set view filters (location, flat type).
     * Uses the standard project display format.
     */
    public void viewMyProjects() {
        System.out.println("\n--- View My Managed Projects ---");
        List<Project> myProjects = getManagedProjects(true);
        viewAndSelectProject(myProjects, "Projects Managed By You");
    }

    /**
     * Get the list of projects managed by the current user.
     * * @param applyUserFilters whether to apply user filters (location, flat
     * type).
     * 
     * @return List of projects managed by the current user, filtered and sorted.
     */
    private List<Project> getManagedProjects(boolean applyUserFilters) {
        List<Project> managed = projectService.getProjectsManagedBy(currentUser.getNric());

        if (applyUserFilters) {
            managed = managed.stream()
                    .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                    .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                    .collect(Collectors.toList());
        }

        managed.sort(Comparator.comparing((Project p) -> p.getProjectName()));

        if (managed.isEmpty()) {
            String filterMsg = (applyUserFilters && (filterLocation != null || filterFlatType != null))
                    ? " matching the current filters."
                    : ".";
            System.out.println("You are not managing any projects" + filterMsg);
        }
        return managed;
    }
}
```

Models\Project.java (334)
```java
/**
 * Represents a BTO (Build-To-Order) housing project.
 * Contains details such as name, neighborhood, flat types offered (with their details),
 * application period dates, managing HDB Manager, officer slot limits, approved officers,
 * and visibility status.
 *
 * @author Jun Yang
 */
package Models;

import Enums.FlatType;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Project {
    private String projectName;
    private String neighborhood;
    private Map<FlatType, FlatTypeDetails> flatTypes;
    private Date applicationOpeningDate;
    private Date applicationClosingDate;
    private final String managerNric;
    private int maxOfficerSlots;
    private final List<String> approvedOfficerNrics;
    private boolean visibility;

    /**
     * Constructs a new Project object with the specified parameters.
     *
     * @param projectName            The name of the project. Must not be null or
     *                               empty.
     * @param neighborhood           The neighborhood of the project. Must not be
     *                               null.
     * @param flatTypes              A map of flat types and their details. Must not
     *                               be null.
     * @param applicationOpeningDate The opening date for applications. Must not be
     *                               null.
     * @param applicationClosingDate The closing date for applications. Must not be
     *                               null and must be after opening date.
     * @param managerNric            The NRIC of the managing HDB Manager. Must not
     *                               be null.
     * @param maxOfficerSlots        The maximum number of officer slots. Must be
     *                               non-negative.
     * @param approvedOfficerNrics   A list of approved officer NRICs. Can be null
     *                               or empty.
     * @param visibility             The visibility status of the project.
     */
    public Project(String projectName, String neighborhood, Map<FlatType, FlatTypeDetails> flatTypes,
            Date applicationOpeningDate, Date applicationClosingDate, String managerNric,
            int maxOfficerSlots, List<String> approvedOfficerNrics, boolean visibility) {
        if (projectName == null || projectName.trim().isEmpty() || neighborhood == null ||
                flatTypes == null || applicationOpeningDate == null || applicationClosingDate == null ||
                managerNric == null || maxOfficerSlots < 0) {
            throw new IllegalArgumentException("Invalid project parameters");
        }
        if (applicationClosingDate.before(applicationOpeningDate)) {
            throw new IllegalArgumentException("Project closing date cannot be before opening date.");
        }
        this.projectName = projectName;
        this.neighborhood = neighborhood;
        this.flatTypes = new HashMap<>(flatTypes);
        this.applicationOpeningDate = applicationOpeningDate;
        this.applicationClosingDate = applicationClosingDate;
        this.managerNric = managerNric;
        this.maxOfficerSlots = maxOfficerSlots;
        this.approvedOfficerNrics = new ArrayList<>(
                approvedOfficerNrics != null ? approvedOfficerNrics : Collections.emptyList());
        this.visibility = visibility;
    }

    /**
     * Gets the project name.
     *
     * @return The project name.
     */
    public String getProjectName() {
        return projectName;
    }

    /**
     * Gets the neighborhood of the project.
     *
     * @return The neighborhood.
     */
    public String getNeighborhood() {
        return neighborhood;
    }

    /**
     * Gets the map of flat types and their details.
     *
     * @return An unmodifiable map of flat types and their details.
     */
    public Map<FlatType, FlatTypeDetails> getFlatTypes() {
        return Collections.unmodifiableMap(flatTypes);
    }

    /**
     * Gets the application opening date.
     *
     * @return The application opening date.
     */
    public Date getApplicationOpeningDate() {
        return applicationOpeningDate;
    }

    /**
     * Gets the application closing date.
     *
     * @return The application closing date.
     */
    public Date getApplicationClosingDate() {
        return applicationClosingDate;
    }

    /**
     * Gets the NRIC of the managing HDB Manager.
     *
     * @return The manager's NRIC.
     */
    public String getManagerNric() {
        return managerNric;
    }

    /**
     * Gets the maximum number of officer slots.
     *
     * @return The maximum number of officer slots.
     */
    public int getMaxOfficerSlots() {
        return maxOfficerSlots;
    }

    /**
     * Gets the list of approved officer NRICs.
     *
     * @return An list of approved officer NRICs.
     */
    public List<String> getApprovedOfficerNrics() {
        return Collections.unmodifiableList(approvedOfficerNrics);
    }

    /**
     * Gets the visibility status of the project.
     *
     * @return The visibility status.
     */
    public boolean isVisible() {
        return visibility;
    }

    /**
     * Gets the number of remaining officer slots.
     *
     * @return The number of remaining officer slots.
     */
    public int getRemainingOfficerSlots() {
        return Math.max(0, maxOfficerSlots - approvedOfficerNrics.size());
    }

    /**
     * Sets the project name.
     * 
     * @param projectName
     */
    public void setProjectName(String projectName) {
        if (projectName != null && !projectName.trim().isEmpty()) {
            this.projectName = projectName.trim();
        }
    }

    /**
     * Sets the neighborhood of the project.
     * 
     * @param neighborhood
     */
    public void setNeighborhood(String neighborhood) {
        if (neighborhood != null) {
            this.neighborhood = neighborhood;
        }
    }

    /**
     * Sets the map of flat types and their details.
     * 
     * @param flatTypes
     */
    public void setFlatTypes(Map<FlatType, FlatTypeDetails> flatTypes) {
        if (flatTypes != null) {
            this.flatTypes = new HashMap<>(flatTypes);
        }
    }

    /**
     * Sets the application opening date.
     * 
     * @param applicationOpeningDate
     */
    public void setApplicationOpeningDate(Date applicationOpeningDate) {
        if (applicationOpeningDate != null) {
            this.applicationOpeningDate = applicationOpeningDate;
        }
    }

    /**
     * Sets the application closing date.
     * 
     * @param applicationClosingDate
     */
    public void setApplicationClosingDate(Date applicationClosingDate) {
        if (applicationClosingDate != null && (this.applicationOpeningDate == null
                || !applicationClosingDate.before(this.applicationOpeningDate))) {
            this.applicationClosingDate = applicationClosingDate;
        } else if (applicationClosingDate != null) {
            System.err.println("Warning: Closing date cannot be before opening date. Not updated.");
        }
    }

    /**
     * Sets the maximum number of officer slots.
     * 
     * @param maxOfficerSlots The maximum number of officer slots.
     */
    public void setMaxOfficerSlots(int maxOfficerSlots) {
        if (maxOfficerSlots >= this.approvedOfficerNrics.size() && maxOfficerSlots >= 0) {
            this.maxOfficerSlots = maxOfficerSlots;
        } else {
            System.err.println("Warning: Cannot set max officer slots (" + maxOfficerSlots
                    + ") below current approved count (" + this.approvedOfficerNrics.size() + "). Value not changed.");
        }
    }

    /**
     * Sets the visibility status of the project.
     * 
     * @param visibility The visibility status.
     */
    public void setVisibility(boolean visibility) {
        this.visibility = visibility;
    }

    /**
     * Adds an approved officer NRIC to the project.
     * 
     * @param officerNric The NRIC of the officer to be added.
     */
    public boolean addApprovedOfficer(String officerNric) {
        if (officerNric != null && getRemainingOfficerSlots() > 0 && !approvedOfficerNrics.contains(officerNric)) {
            approvedOfficerNrics.add(officerNric);
            return true;
        }
        return false;
    }

    /**
     * Removes an approved officer NRIC from the project.
     * 
     * @param officerNric The NRIC of the officer to be removed.
     */
    public boolean removeApprovedOfficer(String officerNric) {
        boolean removed = approvedOfficerNrics.remove(officerNric);
        return removed;
    }

    /**
     * Checks if the application period is active based on the current date.
     *
     * @param currentDate The current date.
     * @return true if the application period is active, false otherwise.
     */
    public boolean isApplicationPeriodActive(Date currentDate) {
        if (currentDate == null || applicationOpeningDate == null || applicationClosingDate == null)
            return false;
        Calendar cal = Calendar.getInstance();
        cal.setTime(applicationClosingDate);
        cal.add(Calendar.DATE, 1);
        Date endOfDayClosing = cal.getTime();

        return !currentDate.before(applicationOpeningDate) && currentDate.before(endOfDayClosing);
    }

    /**
     * Checks if the project is active based on visibility and application period.
     *
     * @param currentDate The current date.
     * @return true if the project is active, false otherwise.
     */
    public boolean isActive(Date currentDate) {
        return this.isVisible() && this.isApplicationPeriodActive(currentDate);
    }

    /**
     * Checks if the application period has expired based on the current date.
     *
     * @param currentDate The current date.
     * @return true if the application period has expired, false otherwise.
     */
    public boolean isApplicationPeriodExpired(Date currentDate) {
        if (currentDate == null || applicationClosingDate == null)
            return false;
        Calendar cal = Calendar.getInstance();
        cal.setTime(applicationClosingDate);
        cal.add(Calendar.DATE, 1);
        Date endOfDayClosing = cal.getTime();
        return currentDate.after(endOfDayClosing);
    }

    /**
     * Gets the flat type details for a specific flat type.
     * 
     * @param type
     * @return The FlatTypeDetails object for the specified flat type, or null if
     *         not found.
     */
    public FlatTypeDetails getFlatTypeDetails(FlatType type) {
        return flatTypes.get(type);
    }

    /**
     * Gets the mutable flat type details for a specific flat type.
     * 
     * @param type
     * @return The FlatTypeDetails object for the specified flat type, or null if
     *         not found.
     */
    public FlatTypeDetails getMutableFlatTypeDetails(FlatType type) {
        return flatTypes.get(type);
    }
}
```

Controllers\ApplicantActionController.java (320)
```java
/**
 * Controller handling specific actions initiated by an Applicant (or an Officer acting as an Applicant),
 * such as viewing open projects, applying for a project, viewing their application status,
 * and requesting withdrawal. Inherits common functionality from BaseController.
 *
 * @author Kai Wang
 */
package Controllers;

import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.Comparator;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.OfficerRegistrationStatus;
import Models.Applicant;
import Models.BTOApplication;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class ApplicantActionController extends BaseController {
    /**
     * Constructs a new ApplicantActionController.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param currentUser                The currently logged-in User (expected to
     *                                   be Applicant or HDBOfficer).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public ApplicantActionController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
    }

    /**
     * Displays a list of BTO projects that are currently open for application and
     * meet the
     * current user's eligibility criteria, unit availability, and any applied view
     * filters.
     * Uses
     * {@link BaseController#getFilteredProjects(boolean, boolean, boolean, boolean, boolean)}
     * with appropriate flags.
     */
    public void viewOpenProjects() {
        System.out.println("\n--- Viewing Available BTO Projects ---");
        List<Project> availableProjects = getFilteredProjects(true, true, true, true, true);
        viewAndSelectProject(availableProjects, "Available BTO Projects");
    }

    /**
     * Guides the applicant through the process of applying for a BTO project.
     * - Checks if the applicant already has an active/booked/pending withdrawal
     * application.
     * - Displays eligible projects (open, visible, eligible, available units).
     * - Prompts the applicant to select a project.
     * - Performs checks specific to HDB Officers applying (cannot apply for
     * handling project or project with pending registration).
     * - Prompts the applicant to select an eligible and available flat type within
     * the chosen project.
     * - Creates a new BTOApplication record with PENDING status.
     * - Updates the Applicant's profile (applicationStatus, appliedProjectName).
     * - Saves the new application.
     */
    public void applyForProject() {
        if (!(currentUser instanceof Applicant)) {
            System.out.println("Error: Only applicants can apply for projects.");
            return;
        }
        Applicant applicant = (Applicant) currentUser;

        if (applicant.hasBooked()) {
            System.out.println("You have already booked a flat for project '" + applicant.getAppliedProjectName()
                    + "'. You cannot apply again.");
            return;
        }
        if (applicant.hasActiveApplication()) {
            System.out.println("You have an active application for project '" + applicant.getAppliedProjectName()
                    + "' with status: " + applicant.getApplicationStatus());
            System.out.println("You must withdraw (and have it approved) or be unsuccessful before applying again.");
            return;
        }
        if (applicant.hasPendingWithdrawal()) {
            System.out.println("You have a withdrawal request pending manager approval for project '"
                    + applicant.getAppliedProjectName() + "'.");
            System.out.println("You cannot apply for a new project until the withdrawal is processed.");
            return;
        }

        System.out.println("\n--- Apply for BTO Project ---");
        List<Project> eligibleProjects = getFilteredProjects(true, true, true, true, true);

        if (eligibleProjects.isEmpty()) {
            System.out.println(
                    "There are currently no open projects you are eligible to apply for based on filters, eligibility, and unit availability.");
            return;
        }

        viewAndSelectProject(eligibleProjects, "Select Project to Apply For");
        Project selectedProject = selectProjectFromList(eligibleProjects);
        if (selectedProject == null)
            return;

        if (currentUser instanceof HDBOfficer) {
            HDBOfficer officer = (HDBOfficer) currentUser;
            Project handlingProject = getOfficerHandlingProject(officer);
            if (handlingProject != null && selectedProject.equals(handlingProject)) {
                System.out.println("Error: You cannot apply for a project you are currently handling as an Officer.");
                return;
            }
            boolean hasPendingRegistration = officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                    .stream()
                    .anyMatch(reg -> reg.getProjectName().equals(selectedProject.getProjectName()) &&
                            reg.getStatus() == OfficerRegistrationStatus.PENDING);
            if (hasPendingRegistration) {
                System.out.println("Error: You cannot apply for a project you have a pending registration for.");
                return;
            }
        }

        FlatType selectedFlatType = selectEligibleFlatType(selectedProject);
        if (selectedFlatType == null)
            return;

        BTOApplication newApplication = new BTOApplication(currentUser.getNric(), selectedProject.getProjectName(),
                selectedFlatType, DateUtils.getCurrentDate());
        applicationService.addApplication(newApplication);

        applicant.setAppliedProjectName(selectedProject.getProjectName());
        applicant.setApplicationStatus(ApplicationStatus.PENDING);
        applicant.setBookedFlatType(null);

        System.out.println("Application submitted successfully for project '" + selectedProject.getProjectName() + "' ("
                + selectedFlatType.getDisplayName() + "). Status: PENDING.");

        applicationService.saveApplications(applicationService.getAllApplications());
    }

    private FlatType selectEligibleFlatType(Project project) {
        List<FlatType> eligibleAndAvailableTypes = project.getFlatTypes().entrySet().stream()
                .filter(entry -> canApplyForFlatType(entry.getKey()) && entry.getValue().getAvailableUnits() > 0)
                .map(entry -> entry.getKey())
                .sorted()
                .collect(Collectors.toList());

        if (eligibleAndAvailableTypes.isEmpty()) {
            System.out.println(
                    "There are no flat types available in this project that you are eligible for and have units remaining.");
            return null;
        }

        if (eligibleAndAvailableTypes.size() == 1) {
            FlatType onlyOption = eligibleAndAvailableTypes.get(0);
            System.out.println("You will be applying for the only eligible and available type: "
                    + onlyOption.getDisplayName() + ".");
            return onlyOption;
        } else {
            System.out.println("Select the flat type you want to apply for:");
            for (int i = 0; i < eligibleAndAvailableTypes.size(); i++) {
                System.out.println((i + 1) + ". " + eligibleAndAvailableTypes.get(i).getDisplayName());
            }
            int typeChoice = getIntInput("Enter choice (or 0 to cancel): ", 0, eligibleAndAvailableTypes.size());

            if (typeChoice == 0) {
                System.out.println("Application cancelled.");
                return null;
            }
            return eligibleAndAvailableTypes.get(typeChoice - 1);
        }
    }

    /**
     * Displays the details of the current or most recent BTO application associated
     * with the logged-in applicant.
     * Retrieves application details from the applicant's profile and the
     * application service.
     * If no current application is linked to the profile but historical records
     * exist, it shows the latest historical one.
     * Displays project name, neighborhood, applied flat type, status, booked type
     * (if applicable), and application date.
     */
    public void viewMyApplication() {
        if (!(currentUser instanceof Applicant))
            return;
        Applicant applicant = (Applicant) currentUser;

        String projectName = applicant.getAppliedProjectName();
        ApplicationStatus status = applicant.getApplicationStatus();

        if (projectName == null || status == null) {
            System.out.println("You do not have any current or past BTO application records synced to your profile.");
            List<BTOApplication> historicalApps = applicationService.getApplicationsByApplicant(applicant.getNric());
            if (!historicalApps.isEmpty()) {
                System.out.println("However, historical application records exist. The latest was:");
                BTOApplication latestApp = historicalApps.stream()
                        .max(Comparator.comparing(app -> app.getApplicationDate()))
                        .orElse(null);
                if (latestApp != null) {
                    Project project = projectService.findProjectByName(latestApp.getProjectName());
                    System.out.println("Project Name: " + latestApp.getProjectName());
                    System.out.println("Neighborhood: "
                            + (project != null ? project.getNeighborhood() : "(Project details not found)"));
                    System.out.println("Flat Type Applied For: "
                            + (latestApp.getFlatTypeApplied() != null ? latestApp.getFlatTypeApplied().getDisplayName()
                                    : "N/A"));
                    System.out.println("Application Status: " + latestApp.getStatus());
                    System.out.println("Application Date: " + DateUtils.formatDate(latestApp.getApplicationDate()));
                }
            }
            return;
        }

        BTOApplication application = applicationService.findApplicationByApplicantAndProject(applicant.getNric(),
                projectName);
        if (application == null) {
            System.out.println(
                    "Error: Your profile indicates an application for '" + projectName
                            + "', but the detailed record could not be found. Please contact support.");
            return;
        }

        Project project = projectService.findProjectByName(projectName);

        System.out.println("\n--- Your BTO Application ---");
        System.out.println("Project Name: " + projectName);
        System.out.println(
                "Neighborhood: " + (project != null ? project.getNeighborhood() : "(Project details not found)"));
        System.out.println("Flat Type Applied For: "
                + (application.getFlatTypeApplied() != null ? application.getFlatTypeApplied().getDisplayName()
                        : "N/A"));
        System.out.println("Application Status: " + status);
        if (status == ApplicationStatus.BOOKED && applicant.getBookedFlatType() != null) {
            System.out.println("Booked Flat Type: " + applicant.getBookedFlatType().getDisplayName());
        }
        System.out.println("Application Date: " + DateUtils.formatDate(application.getApplicationDate()));
    }

    /**
     * Allows an applicant to request withdrawal of their current BTO application.
     * - Checks if the applicant has an application eligible for withdrawal
     * (PENDING, SUCCESSFUL, or BOOKED status).
     * - Retrieves the application record.
     * - Prompts for confirmation.
     * - If confirmed, updates the application status and the applicant's profile
     * status to PENDING_WITHDRAWAL.
     * - Saves the updated application. Manager approval is required to finalize the
     * withdrawal.
     */
    public void requestWithdrawal() {
        if (!(currentUser instanceof Applicant))
            return;
        Applicant applicant = (Applicant) currentUser;

        String currentProject = applicant.getAppliedProjectName();
        ApplicationStatus currentStatus = applicant.getApplicationStatus();

        if (currentProject == null || currentStatus == null) {
            System.out.println("You do not have an application to withdraw.");
            return;
        }

        if (currentStatus != ApplicationStatus.PENDING &&
                currentStatus != ApplicationStatus.SUCCESSFUL &&
                currentStatus != ApplicationStatus.BOOKED) {
            System.out
                    .println("Your application status (" + currentStatus + ") is not eligible for withdrawal request.");
            System.out.println("You can only request withdrawal if your status is PENDING, SUCCESSFUL, or BOOKED.");
            return;
        }

        BTOApplication application = applicationService.findApplicationByApplicantAndProject(applicant.getNric(),
                currentProject);
        if (application == null) {
            System.out.println(
                    "Error: Could not find the application record for project '" + currentProject
                            + "' to request withdrawal. Please contact support.");
            return;
        }
        if (application.getStatus() != currentStatus) {
            System.out.println("Error: Application status mismatch between profile (" + currentStatus + ") and record ("
                    + application.getStatus() + "). Please re-login or contact support.");
            return;
        }

        System.out.println("\n--- Request Application Withdrawal ---");
        System.out.println("Project: " + application.getProjectName());
        System.out.println("Current Status: " + currentStatus);
        System.out.print(
                "Are you sure you want to request withdrawal for this application? Manager approval is required. (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            application.setStatus(ApplicationStatus.PENDING_WITHDRAWAL);

            applicant.setApplicationStatus(ApplicationStatus.PENDING_WITHDRAWAL);

            System.out.println("Withdrawal request submitted successfully.");
            System.out.println("Your application status is now PENDING_WITHDRAWAL and requires Manager approval.");

            applicationService.saveApplications(applicationService.getAllApplications());

        } else {
            System.out.println("Withdrawal request cancelled.");
        }
    }
}
```

Services\ProjectService.java (312)
```java
/**
 * Service implementation for managing BTO Project data.
 * Handles loading project data from ProjectList.csv, validating against user data,
 * and saving projects back to the CSV file. Provides methods for finding, retrieving,
 * adding, and removing projects.
 *
 * @author Jordon
 */
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import Enums.FlatType;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Utils.DateUtils;
import Parsers.Dparse;
import Parsers.LSparse;

public class ProjectService implements IProjectService {
    private static final String DELIMITER = ",";
    private static final String DATA_DIR = "data";
    private static final String LIST_DELIMITER = ";";
    private static final String[] PROJECT_HEADER = {
            "Project Name", "Neighborhood", "Type 1", "Number of units for Type 1", "Selling price for Type 1",
            "Type 2", "Number of units for Type 2", "Selling price for Type 2",
            "Application opening date", "Application closing date", "Manager", "Officer Slot", "Officer", "Visibility"
    };
    private static final String PROJECT_FILE = DATA_DIR + File.separator + "ProjectList.csv";

    private List<Project> projects;

    /**
     * Constructs a new ProjectService. Initializes the internal project list.
     */
    public ProjectService() {
        this.projects = new ArrayList<>();
    }

    /**
     * Loads project data from ProjectList.csv.
     * Validates project names (uniqueness), flat types, dates, manager NRIC (must
     * be a valid HDBManager),
     * and officer NRICs (must be valid HDBOfficers). Adjusts officer lists based on
     * validity.
     * Populates the internal project list.
     *
     * @param users A map of NRIC to User objects, used for validating manager and
     *              officer NRICs.
     * @return A copy of the list containing all loaded and validated projects.
     */
    @Override
    public List<Project> loadProjects(Map<String, User> users) {
        this.projects.clear();
        Set<String> projectNames = new HashSet<>();

        CsvRW.readCsv(PROJECT_FILE, PROJECT_HEADER.length).forEach(data -> {
            try {
                String projectName = data[0].trim();
                if (projectName.isEmpty() || !projectNames.add(projectName.toLowerCase())) {
                    if (!projectName.isEmpty())
                        System.err.println("Skipping duplicate project name: " + projectName);
                    return;
                }

                String neighborhood = data[1].trim();
                Map<FlatType, FlatTypeDetails> flatTypes = new HashMap<>();

                if (data[2] != null && !data[2].trim().isEmpty()) {
                    FlatType type1 = FlatType.fromString(data[2].trim());
                    if (type1 != null) {
                        int units1 = Integer.parseInt(data[3].trim());
                        double price1 = Double.parseDouble(data[4].trim());
                        flatTypes.put(type1, new FlatTypeDetails(units1, units1, price1));
                    } else {
                        System.err.println("Warning: Unknown flat type '" + data[2] + "' in project '" + projectName
                                + "'. Skipping type.");
                    }
                }

                if (data[5] != null && !data[5].trim().isEmpty()) {
                    FlatType type2 = FlatType.fromString(data[5].trim());
                    if (type2 != null) {
                        int units2 = Integer.parseInt(data[6].trim());
                        double price2 = Double.parseDouble(data[7].trim());
                        flatTypes.put(type2, new FlatTypeDetails(units2, units2, price2));
                    } else {
                        System.err.println("Warning: Unknown flat type '" + data[5] + "' in project '" + projectName
                                + "'. Skipping type.");
                    }
                }

                Date openingDate = Dparse.parseDate(data[8].trim());
                Date closingDate = Dparse.parseDate(data[9].trim());
                String managerNric = data[10].trim();
                int officerSlots = Integer.parseInt(data[11].trim());

                List<String> officers = LSparse.parseListString(data[12]);

                boolean visibility = false;
                if (data.length > 13 && data[13] != null) {
                    String visibilityStr = data[13].trim();
                    if (visibilityStr.equals("1")) {
                        visibility = true;
                    } else if (!visibilityStr.equals("0") && !visibilityStr.isEmpty()) {
                        System.err.println("Warning: Invalid visibility value '" + visibilityStr + "' for project '"
                                + projectName + "'. Assuming false.");
                    }
                }

                if (!users.containsKey(managerNric) || !(users.get(managerNric) instanceof HDBManager)) {
                    System.err.println("Warning: Project '" + projectName + "' has invalid or non-manager NRIC: "
                            + managerNric + ". Skipping project.");
                    projectNames.remove(projectName.toLowerCase());
                    return;
                }
                if (openingDate == null || closingDate == null || closingDate.before(openingDate)) {
                    System.err.println("Warning: Project '" + projectName + "' has invalid application dates (Open: "
                            + data[8] + ", Close: " + data[9] + "). Skipping project.");
                    projectNames.remove(projectName.toLowerCase());
                    return;
                }
                List<String> validOfficers = new ArrayList<>();
                List<String> invalidOfficers = new ArrayList<>();
                for (String nric : officers) {
                    if (users.containsKey(nric) && users.get(nric) instanceof HDBOfficer) {
                        validOfficers.add(nric);
                    } else {
                        invalidOfficers.add(nric);
                    }
                }
                if (!invalidOfficers.isEmpty()) {
                    System.err.println("Warning: Project '" + projectName
                            + "' contains invalid or non-officer NRICs in its officer list: " + invalidOfficers
                            + ". Only valid officers retained.");
                }
                if (validOfficers.size() > officerSlots) {
                    System.err.println(
                            "Warning: Project '" + projectName + "' has more approved officers (" + validOfficers.size()
                                    + ") than slots (" + officerSlots + "). Check data. Using officer list as is.");
                }

                Project project = new Project(projectName, neighborhood, flatTypes, openingDate, closingDate,
                        managerNric, officerSlots, validOfficers, visibility);
                this.projects.add(project);

            } catch (NumberFormatException e) {
                System.err.println("Error parsing number in project data: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in project data: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
            } catch (Exception e) {
                System.err.println("Unexpected error parsing project data line: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
                e.printStackTrace();
            }
        });

        System.out.println("Loaded " + this.projects.size() + " projects.");
        return new ArrayList<>(this.projects);
    }

    /**
     * Saves the provided list of projects to ProjectList.csv.
     * Formats project data, including flat type details (saving total units) and
     * officer lists, for CSV storage.
     * Overwrites the existing file. Updates the internal project list to match the
     * saved state.
     *
     * @param projectsToSave The list of Project objects to save.
     */
    @Override
    public void saveProjects(List<Project> projectsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(PROJECT_HEADER);

        projectsToSave.forEach(project -> {
            String[] data = new String[PROJECT_HEADER.length];
            data[0] = project.getProjectName();
            data[1] = project.getNeighborhood();

            FlatTypeDetails twoRoomDetails = project.getFlatTypeDetails(FlatType.TWO_ROOM);
            FlatTypeDetails threeRoomDetails = project.getFlatTypeDetails(FlatType.THREE_ROOM);

            if (twoRoomDetails != null) {
                data[2] = FlatType.TWO_ROOM.getDisplayName();
                data[3] = String.valueOf(twoRoomDetails.getTotalUnits());
                data[4] = String.valueOf(twoRoomDetails.getSellingPrice());
            } else {
                data[2] = "";
                data[3] = "0";
                data[4] = "0";
            }

            if (threeRoomDetails != null) {
                data[5] = FlatType.THREE_ROOM.getDisplayName();
                data[6] = String.valueOf(threeRoomDetails.getTotalUnits());
                data[7] = String.valueOf(threeRoomDetails.getSellingPrice());
            } else {
                data[5] = "";
                data[6] = "0";
                data[7] = "0";
            }

            data[8] = DateUtils.formatDate(project.getApplicationOpeningDate());
            data[9] = DateUtils.formatDate(project.getApplicationClosingDate());
            data[10] = project.getManagerNric();
            data[11] = String.valueOf(project.getMaxOfficerSlots());
            String officers = String.join(LIST_DELIMITER, project.getApprovedOfficerNrics());
            data[12] = officers;

            data[13] = project.isVisible() ? "1" : "0";

            dataList.add(data);
        });
        CsvRW.writeCsv(PROJECT_FILE, dataList);
        System.out.println("Saved projects.");
        this.projects = new ArrayList<>(projectsToSave);
    }

    /**
     * Finds a project by its name (case-insensitive) from the internally managed
     * list.
     *
     * @param name The name of the project to find.
     * @return The Project object if found, or null if the name is null, empty, or
     *         not found.
     */
    @Override
    public Project findProjectByName(String name) {
        if (name == null || name.trim().isEmpty())
            return null;
        return this.projects.stream()
                .filter(p -> p.getProjectName().equalsIgnoreCase(name.trim()))
                .findFirst()
                .orElse(null);
    }

    /**
     * Retrieves a copy of the list containing all projects currently managed by the
     * service.
     * Returning a copy prevents external modification of the internal state.
     *
     * @return A new ArrayList containing all Project objects.
     */
    @Override
    public List<Project> getAllProjects() {
        return new ArrayList<>(this.projects);
    }

    /**
     * Retrieves a list of projects managed by a specific HDB Manager NRIC.
     * Filters the internal project list based on the managerNric field.
     *
     * @param managerNric The NRIC of the manager.
     * @return A list of projects managed by the specified manager. Returns an empty
     *         list if NRIC is null or no projects are found.
     */
    @Override
    public List<Project> getProjectsManagedBy(String managerNric) {
        if (managerNric == null)
            return new ArrayList<>();
        return this.projects.stream()
                .filter(p -> managerNric.equals(p.getManagerNric()))
                .collect(Collectors.toList());
    }

    /**
     * Adds a new project to the internal list if a project with the same name
     * doesn't already exist.
     * Prints an error message if a duplicate name is detected.
     *
     * @param project The Project object to add.
     */
    @Override
    public void addProject(Project project) {
        if (project != null && findProjectByName(project.getProjectName()) == null) {
            this.projects.add(project);
        } else if (project != null) {
            System.err.println(
                    "Project with name '" + project.getProjectName() + "' already exists. Cannot add duplicate.");
        }
    }

    /**
     * Removes a project from the internal list based on its name.
     *
     * @param project The Project object to remove. If null, the method does
     *                nothing.
     * @return true if a project with the matching name was found and removed, false
     *         otherwise.
     */
    @Override
    public boolean removeProject(Project project) {
        if (project != null) {
            return this.projects.removeIf(p -> p.getProjectName().equals(project.getProjectName()));
        }
        return false;
    }
}
```

Services\ApplicationService.java (293)
```java
/**
 * Service implementation for managing BTO Application data.
 * Handles loading application data from applications.csv, adjusting project unit availability based on
 * booked applications, and saving applications back. Provides methods for finding, retrieving,
 * adding, and removing applications.
 *
 * @author Jordon
 */

package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.Project;
import Parsers.Dparse;
import Utils.DateUtils;

public class ApplicationService implements IApplicationService {
    private static final String DATA_DIR = "data";
    private static final String APPLICATION_FILE = DATA_DIR + File.separator + "applications.csv";
    private static final String[] APPLICATION_HEADER = { "ApplicationID", "ApplicantNRIC", "ProjectName",
            "FlatTypeApplied", "Status", "ApplicationDate" };
    private static final String DELIMITER = ",";

    private Map<String, BTOApplication> applications;

    /**
     * Constructs a new ApplicationService. Initializes the internal application
     * map.
     */
    public ApplicationService() {
        this.applications = new HashMap<>();
    }

    /**
     * Loads BTO application data from applications.csv.
     * Validates application IDs (uniqueness), dates, and enum values.
     * Tracks applications with 'BOOKED' status and adjusts the `availableUnits` in
     * the corresponding
     * Project's FlatTypeDetails objects provided in the `projects` list.
     * Populates the internal application map.
     *
     * @param projects A list of all Project objects, used for finding projects and
     *                 adjusting their unit counts.
     * @return A copy of the map containing all loaded applications (ApplicationID
     *         to BTOApplication object).
     */
    @Override
    public Map<String, BTOApplication> loadApplications(List<Project> projects) {
        this.applications.clear();
        Map<Project, Map<FlatType, Integer>> bookedCounts = new HashMap<>();

        CsvRW.readCsv(APPLICATION_FILE, APPLICATION_HEADER.length).forEach(data -> {
            try {
                String appId = data[0].trim();
                if (appId.isEmpty() || this.applications.containsKey(appId)) {
                    if (!appId.isEmpty())
                        System.err.println("Skipping duplicate application ID: " + appId);
                    return;
                }
                String applicantNric = data[1].trim();
                String projectName = data[2].trim();
                FlatType flatType = FlatType.fromString(data[3].trim());
                ApplicationStatus status = ApplicationStatus.valueOf(data[4].trim().toUpperCase());
                Date appDate = Dparse.parseDate(data[5].trim());

                if (appDate == null) {
                    System.err.println("Skipping application with invalid date: " + appId);
                    return;
                }
                if (flatType == null && (status == ApplicationStatus.BOOKED || status == ApplicationStatus.SUCCESSFUL
                        || status == ApplicationStatus.PENDING_WITHDRAWAL)) {
                    System.err.println("Warning: Application " + appId + " is " + status
                            + " but has invalid/missing flat type '" + data[3] + "'. Status might be inconsistent.");
                }

                BTOApplication application = new BTOApplication(appId, applicantNric, projectName, flatType, status,
                        appDate);
                this.applications.put(application.getApplicationId(), application);

                if (status == ApplicationStatus.BOOKED && flatType != null) {
                    Project project = projects.stream()
                            .filter(p -> p.getProjectName().equalsIgnoreCase(projectName))
                            .findFirst().orElse(null);
                    if (project != null) {
                        bookedCounts.computeIfAbsent(project, _ -> new HashMap<>())
                                .merge(flatType, 1, (a, b) -> a + b);
                    } else {
                        System.err.println("Warning: Booked application " + appId + " refers to non-existent project '"
                                + projectName + "'. Unit count cannot be adjusted.");
                    }
                }

            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in application data: " + String.join(DELIMITER, data)
                        + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing application data line: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
            }
        });

        bookedCounts.forEach((project, typeCounts) -> {
            typeCounts.forEach((type, count) -> {
                FlatTypeDetails details = project.getMutableFlatTypeDetails(type);
                if (details != null) {
                    int initialAvailable = details.getTotalUnits();
                    int finalAvailable = Math.max(0, initialAvailable - count);
                    details.setAvailableUnits(finalAvailable);
                    if (count > details.getTotalUnits()) {
                        System.err.println("Error: More flats booked (" + count + ") than total units ("
                                + details.getTotalUnits() + ") for " + project.getProjectName() + "/"
                                + type.getDisplayName() + ". Available units set to 0.");
                    }
                } else {
                    System.err.println("Warning: Trying to adjust units for non-existent flat type "
                            + type.getDisplayName() + " in project " + project.getProjectName());
                }
            });
        });

        System.out.println("Loaded " + this.applications.size() + " applications.");
        return new HashMap<>(this.applications);
    }

    /**
     * Saves the provided map of BTO applications to applications.csv.
     * Formats application data for CSV storage.
     * Overwrites the existing file. Updates the internal application map to match
     * the saved state.
     *
     * @param applicationsToSave The map of applications (ApplicationID to
     *                           BTOApplication object) to save.
     */
    @Override
    public void saveApplications(Map<String, BTOApplication> applicationsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(APPLICATION_HEADER);
        applicationsToSave.values().stream()
                .sorted(Comparator.comparing((BTOApplication app) -> app.getApplicationId()))
                .forEach(app -> {
                    dataList.add(new String[] {
                            app.getApplicationId(),
                            app.getApplicantNric(),
                            app.getProjectName(),
                            app.getFlatTypeApplied() == null ? "" : app.getFlatTypeApplied().name(),
                            app.getStatus().name(),
                            DateUtils.formatDate(app.getApplicationDate())
                    });
                });
        CsvRW.writeCsv(APPLICATION_FILE, dataList);
        System.out.println("Saved applications.");
        this.applications = new HashMap<>(applicationsToSave);
    }

    /**
     * Finds a BTO application by its unique ID from the internally managed map.
     *
     * @param applicationId The ID of the application to find.
     * @return The BTOApplication object if found, or null otherwise.
     */
    @Override
    public BTOApplication findApplicationById(String applicationId) {
        return this.applications.get(applicationId);
    }

    /**
     * Finds a specific BTO application based on the applicant's NRIC and the
     * project name.
     * Constructs the expected application ID (NRIC_ProjectName) and uses
     * `findApplicationById`.
     *
     * @param nric        The NRIC of the applicant.
     * @param projectName The name of the project.
     * @return The BTOApplication object if found, or null if NRIC/projectName is
     *         null or the application doesn't exist.
     */
    @Override
    public BTOApplication findApplicationByApplicantAndProject(String nric, String projectName) {
        if (nric == null || projectName == null)
            return null;
        String appId = nric + "_" + projectName;
        return findApplicationById(appId);
    }

    /**
     * Retrieves a list of all BTO applications submitted for a specific project.
     * Filters the internal application map based on the projectName field.
     *
     * @param projectName The name of the project.
     * @return A list of BTOApplication objects for the specified project. Returns
     *         an empty list if projectName is null or no applications are found.
     */
    @Override
    public List<BTOApplication> getApplicationsByProject(String projectName) {
        if (projectName == null)
            return new ArrayList<>();
        return this.applications.values().stream()
                .filter(app -> projectName.equals(app.getProjectName()))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a list of all BTO applications that currently have a specific
     * status.
     * Filters the internal application map based on the status field.
     *
     * @param status The ApplicationStatus to filter by.
     * @return A list of BTOApplication objects with the specified status. Returns
     *         an empty list if status is null or no applications match.
     */
    @Override
    public List<BTOApplication> getApplicationsByStatus(ApplicationStatus status) {
        if (status == null)
            return new ArrayList<>();
        return this.applications.values().stream()
                .filter(app -> status.equals(app.getStatus()))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a list of all BTO applications submitted by a specific applicant.
     * Filters the internal application map based on the applicantNric field.
     *
     * @param nric The NRIC of the applicant.
     * @return A list of BTOApplication objects submitted by the specified
     *         applicant. Returns an empty list if nric is null or no applications
     *         are found.
     */
    @Override
    public List<BTOApplication> getApplicationsByApplicant(String nric) {
        if (nric == null)
            return new ArrayList<>();
        return this.applications.values().stream()
                .filter(app -> nric.equals(app.getApplicantNric()))
                .collect(Collectors.toList());
    }

    /**
     * Adds a new BTO application to the internal map if an application with the
     * same ID doesn't already exist.
     * Prints an error message if a duplicate ID is detected.
     *
     * @param application The BTOApplication object to add.
     */
    @Override
    public void addApplication(BTOApplication application) {
        if (application != null && !this.applications.containsKey(application.getApplicationId())) {
            this.applications.put(application.getApplicationId(), application);
        } else if (application != null) {
            System.err.println("Application with ID " + application.getApplicationId() + " already exists.");
        }
    }

    /**
     * Removes a BTO application from the internal map based on its ID.
     *
     * @param applicationId The ID of the application to remove. If null, the method
     *                      does nothing.
     * @return true if the application was found and removed, false otherwise.
     */
    @Override
    public boolean removeApplication(String applicationId) {
        if (applicationId != null) {
            return this.applications.remove(applicationId) != null;
        }
        return false;
    }

    /**
     * Retrieves a copy of the map containing all BTO applications currently managed
     * by the service.
     * Returning a copy prevents external modification of the internal state.
     *
     * @return A new HashMap containing all applications (ApplicationID to
     *         BTOApplication object).
     */
    @Override
    public Map<String, BTOApplication> getAllApplications() {
        return new HashMap<>(this.applications);
    }
}
```

Services\OfficerRegistrationService.java (268)
```java
/**
 * Service implementation for managing HDB Officer project registration data.
 * Handles loading registration data from officer_registrations.csv, validating against user and project data,
 * and saving registrations back. Provides methods for finding, retrieving, adding, and removing registrations.
 *
 * @author Jordon
 */
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.OfficerRegistrationStatus;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Parsers.Dparse;
import Utils.DateUtils;

public class OfficerRegistrationService implements IOfficerRegistrationService {
    private static final String DATA_DIR = "data";
    private static final String DELIMITER = ",";
    private static final String OFFICER_REGISTRATION_FILE = DATA_DIR + File.separator + "officer_registrations.csv";
    private static final String[] OFFICER_REGISTRATION_HEADER = { "RegistrationID", "OfficerNRIC", "ProjectName",
            "Status", "RegistrationDate" };

    private Map<String, OfficerRegistration> registrations;

    /**
     * Constructs a new OfficerRegistrationService. Initializes the internal
     * registration map.
     */
    public OfficerRegistrationService() {
        this.registrations = new HashMap<>();
    }

    /**
     * Loads officer registration data from officer_registrations.csv.
     * Validates registration IDs (uniqueness), dates, enum values, officer NRICs
     * (must exist in `users` and be an HDBOfficer),
     * and project names (must exist in `projects`).
     * Populates the internal registration map.
     *
     * @param users    A map of NRIC to User objects, used for validating officer
     *                 NRICs.
     * @param projects A list of all Project objects, used for validating project
     *                 names.
     * @return A copy of the map containing all loaded and validated registrations
     *         (RegistrationID to OfficerRegistration object).
     */
    @Override
    public Map<String, OfficerRegistration> loadOfficerRegistrations(Map<String, User> users, List<Project> projects) {
        this.registrations.clear();

        CsvRW.readCsv(OFFICER_REGISTRATION_FILE, OFFICER_REGISTRATION_HEADER.length).forEach(data -> {
            try {
                String regId = data[0].trim();
                if (regId.isEmpty() || this.registrations.containsKey(regId)) {
                    if (!regId.isEmpty())
                        System.err.println("Skipping duplicate registration ID: " + regId);
                    return;
                }
                String officerNric = data[1].trim();
                String projectName = data[2].trim();
                OfficerRegistrationStatus status = OfficerRegistrationStatus.valueOf(data[3].trim().toUpperCase());
                Date regDate = Dparse.parseDate(data[4].trim());

                if (regDate == null) {
                    System.err.println("Skipping registration with invalid date: " + regId);
                    return;
                }

                if (!users.containsKey(officerNric) || !(users.get(officerNric) instanceof HDBOfficer)) {
                    System.err.println("Warning: Registration " + regId + " refers to invalid or non-officer NRIC: "
                            + officerNric + ". Skipping registration.");
                    return;
                }
                boolean projectExists = projects.stream()
                        .anyMatch(p -> p.getProjectName().equalsIgnoreCase(projectName));
                if (!projectExists) {
                    System.err.println("Warning: Registration " + regId + " refers to non-existent project: "
                            + projectName + ". Skipping registration.");
                    return;
                }

                OfficerRegistration registration = new OfficerRegistration(regId, officerNric, projectName, status,
                        regDate);
                this.registrations.put(registration.getRegistrationId(), registration);
            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in officer registration data: "
                        + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing officer registration data line: " + String.join(DELIMITER, data)
                        + " - " + e.getMessage());
            }
        });
        System.out.println("Loaded " + this.registrations.size() + " officer registrations.");
        return new HashMap<>(this.registrations);
    }

    /**
     * Saves the provided map of officer registrations to officer_registrations.csv.
     * Formats registration data for CSV storage.
     * Overwrites the existing file. Updates the internal registration map to match
     * the saved state.
     *
     * @param registrationsToSave The map of registrations (RegistrationID to
     *                            OfficerRegistration object) to save.
     */
    @Override
    public void saveOfficerRegistrations(Map<String, OfficerRegistration> registrationsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(OFFICER_REGISTRATION_HEADER);
        registrationsToSave.values().stream()
                .sorted(Comparator.comparing((OfficerRegistration oR) -> oR.getRegistrationId()))
                .forEach(reg -> {
                    dataList.add(new String[] {
                            reg.getRegistrationId(),
                            reg.getOfficerNric(),
                            reg.getProjectName(),
                            reg.getStatus().name(),
                            DateUtils.formatDate(reg.getRegistrationDate())
                    });
                });
        CsvRW.writeCsv(OFFICER_REGISTRATION_FILE, dataList);
        System.out.println("Saved officer registrations.");
        this.registrations = new HashMap<>(registrationsToSave);
    }

    /**
     * Finds an officer registration by its unique ID from the internally managed
     * map.
     *
     * @param registrationId The ID of the registration to find.
     * @return The OfficerRegistration object if found, or null otherwise.
     */
    @Override
    public OfficerRegistration findRegistrationById(String registrationId) {
        return this.registrations.get(registrationId);
    }

    /**
     * Retrieves a list of all registrations (regardless of status) made by a
     * specific HDB Officer.
     * Filters the internal registration map based on the officerNric field.
     *
     * @param officerNric The NRIC of the officer.
     * @return A list of OfficerRegistration objects for the specified officer.
     *         Returns an empty list if NRIC is null or no registrations are found.
     */
    @Override
    public List<OfficerRegistration> getRegistrationsByOfficer(String officerNric) {
        if (officerNric == null)
            return new ArrayList<>();
        return this.registrations.values().stream()
                .filter(reg -> officerNric.equals(reg.getOfficerNric()))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a list of all registrations (regardless of status) associated with
     * a specific project.
     * Filters the internal registration map based on the projectName field.
     *
     * @param projectName The name of the project.
     * @return A list of OfficerRegistration objects for the specified project.
     *         Returns an empty list if projectName is null or no registrations are
     *         found.
     */
    @Override
    public List<OfficerRegistration> getRegistrationsByProject(String projectName) {
        if (projectName == null)
            return new ArrayList<>();
        return this.registrations.values().stream()
                .filter(reg -> projectName.equals(reg.getProjectName()))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a list of all officer registrations that currently have a specific
     * status.
     * Filters the internal registration map based on the status field.
     *
     * @param status The OfficerRegistrationStatus to filter by.
     * @return A list of OfficerRegistration objects with the specified status.
     *         Returns an empty list if status is null or no registrations match.
     */
    @Override
    public List<OfficerRegistration> getRegistrationsByStatus(OfficerRegistrationStatus status) {
        if (status == null)
            return new ArrayList<>();
        return this.registrations.values().stream()
                .filter(reg -> status.equals(reg.getStatus()))
                .collect(Collectors.toList());
    }

    /**
     * Finds the specific registration record indicating which project an officer is
     * currently approved to handle.
     * Filters for APPROVED status and returns the first match found. Assumes an
     * officer handles at most one project at a time.
     *
     * @param officerNric The NRIC of the officer.
     * @return The OfficerRegistration object with APPROVED status for the officer,
     *         or null if none is found or NRIC is null.
     */
    @Override
    public OfficerRegistration getApprovedRegistrationForOfficer(String officerNric) {
        if (officerNric == null)
            return null;
        return this.registrations.values().stream()
                .filter(reg -> officerNric.equals(reg.getOfficerNric())
                        && reg.getStatus() == OfficerRegistrationStatus.APPROVED)
                .findFirst()
                .orElse(null);
    }

    /**
     * Adds a new officer registration to the internal map if a registration with
     * the same ID doesn't already exist.
     * Prints an error message if a duplicate ID is detected.
     *
     * @param registration The OfficerRegistration object to add.
     */
    @Override
    public void addRegistration(OfficerRegistration registration) {
        if (registration != null && !this.registrations.containsKey(registration.getRegistrationId())) {
            this.registrations.put(registration.getRegistrationId(), registration);
        } else if (registration != null) {
            System.err.println("Registration with ID " + registration.getRegistrationId() + " already exists.");
        }
    }

    /**
     * Removes an officer registration from the internal map based on its ID.
     *
     * @param registrationId The ID of the registration to remove. If null, the
     *                       method does nothing.
     * @return true if the registration was found and removed, false otherwise.
     */
    @Override
    public boolean removeRegistration(String registrationId) {
        if (registrationId != null) {
            return this.registrations.remove(registrationId) != null;
        }
        return false;
    }

    /**
     * Retrieves a copy of the map containing all officer registrations currently
     * managed by the service.
     * Returning a copy prevents external modification of the internal state.
     *
     * @return A new HashMap containing all registrations (RegistrationID to
     *         OfficerRegistration object).
     */
    @Override
    public Map<String, OfficerRegistration> getAllRegistrations() {
        return new HashMap<>(this.registrations);
    }
}
```

Models\Enquiry.java (250)
```java
/**
 * Represents an enquiry submitted by an applicant regarding a specific BTO project.
 * Contains the enquiry text, applicant details, project name, dates, and potentially a reply from an HDB staff member.
 * Manages its own unique ID generation using a static counter.
 *
 * @author Jordon
 */
package Models;

import java.util.Date;

public class Enquiry {
    private final String enquiryId;
    private final String applicantNric;
    private final String projectName;
    private String enquiryText;
    private String replyText;
    private String repliedByNric;
    private final Date enquiryDate;
    private Date replyDate;
    private static long nextId = 1;

    /**
     * Constructs a new Enquiry object when an applicant submits it.
     * Automatically generates a unique enquiry ID (e.g., "ENQ1", "ENQ2", ...).
     * Initializes reply fields to null.
     *
     * @param applicantNric The NRIC of the applicant submitting the enquiry. Cannot
     *                      be null.
     * @param projectName   The name of the project the enquiry is about. Cannot be
     *                      null.
     * @param enquiryText   The text content of the enquiry. Cannot be null or
     *                      empty.
     * @param enquiryDate   The date the enquiry was submitted. Cannot be null.
     * @throws IllegalArgumentException if any parameter is invalid (null or empty
     *                                  text).
     */
    public Enquiry(String applicantNric, String projectName, String enquiryText, Date enquiryDate) {
        if (applicantNric == null || projectName == null || enquiryText == null || enquiryText.trim().isEmpty()
                || enquiryDate == null) {
            throw new IllegalArgumentException("Invalid Enquiry parameters");
        }
        synchronized (Enquiry.class) {
            this.enquiryId = "ENQ" + (nextId++);
        }
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.enquiryText = enquiryText;
        this.enquiryDate = enquiryDate;
        this.replyText = null;
        this.repliedByNric = null;
        this.replyDate = null;
    }

    /**
     * Constructs an Enquiry object when loading data from storage.
     * Allows setting all fields, including the ID, reply details, and dates.
     * Updates the static `nextId` counter based on the loaded ID to prevent future
     * collisions.
     *
     * @param enquiryId     The unique ID of the enquiry being loaded. Cannot be
     *                      null.
     * @param applicantNric The NRIC of the applicant. Cannot be null.
     * @param projectName   The name of the project. Cannot be null.
     * @param enquiryText   The text content of the enquiry. Cannot be null.
     * @param replyText     The text of the reply (can be null if not replied).
     * @param repliedByNric The NRIC of the staff member who replied (can be null).
     * @param enquiryDate   The date the enquiry was submitted. Cannot be null.
     * @param replyDate     The date the reply was submitted (can be null).
     * @throws IllegalArgumentException if required fields (ID, NRIC, project, text,
     *                                  enquiry date) are null.
     */
    public Enquiry(String enquiryId, String applicantNric, String projectName, String enquiryText, String replyText,
            String repliedByNric, Date enquiryDate, Date replyDate) {
        if (enquiryId == null || applicantNric == null || projectName == null || enquiryText == null
                || enquiryDate == null) {
            throw new IllegalArgumentException("Required Enquiry fields cannot be null when loading");
        }
        this.enquiryId = enquiryId;
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.enquiryText = enquiryText;
        this.replyText = (replyText == null || replyText.trim().isEmpty()) ? null : replyText.trim();
        this.repliedByNric = (repliedByNric == null || repliedByNric.trim().isEmpty()) ? null : repliedByNric.trim();
        this.enquiryDate = enquiryDate;
        this.replyDate = replyDate;

        updateNextId(enquiryId);
    }

    /**
     * Static helper method called during loading to update the `nextId` counter.
     * Ensures that newly generated IDs will be greater than any loaded ID.
     * Parses the numeric part of the loaded ID (e.g., "123" from "ENQ123").
     * Synchronized to handle potential concurrency if loading were multi-threaded
     * (though currently unlikely).
     *
     * @param loadedEnquiryId The enquiry ID string loaded from storage.
     */
    public static void updateNextId(String loadedEnquiryId) {
        if (loadedEnquiryId != null && loadedEnquiryId.startsWith("ENQ")) {
            try {
                long idNum = Long.parseLong(loadedEnquiryId.substring(3));
                synchronized (Enquiry.class) {
                    if (idNum >= nextId) {
                        nextId = idNum + 1;
                    }
                }
            } catch (NumberFormatException | StringIndexOutOfBoundsException e) {
                System.err.println("Warning: Could not parse enquiry ID for nextId update: " + loadedEnquiryId);
            }
        }
    }

    /**
     * Static method to be called once after all enquiries have been loaded.
     * Prints the final value of the `nextId` counter for informational purposes.
     */
    public static void finalizeNextIdInitialization() {
        System.out.println("Enquiry nextId initialized to: " + nextId);
    }

    /**
     * Gets the unique ID of the enquiry.
     * 
     * @return The enquiry ID string (e.g., "ENQ1").
     */
    public String getEnquiryId() {
        return enquiryId;
    }

    /**
     * Gets the NRIC of the applicant who submitted the enquiry.
     * 
     * @return The applicant's NRIC string.
     */
    public String getApplicantNric() {
        return applicantNric;
    }

    /**
     * Gets the name of the project the enquiry is associated with.
     * 
     * @return The project name string.
     */
    public String getProjectName() {
        return projectName;
    }

    /**
     * Gets the text content of the enquiry.
     * 
     * @return The enquiry text string.
     */
    public String getEnquiryText() {
        return enquiryText;
    }

    /**
     * Gets the text content of the reply, if any.
     * 
     * @return The reply text string, or null if not replied.
     */
    public String getReplyText() {
        return replyText;
    }

    /**
     * Gets the NRIC of the staff member who replied, if any.
     * 
     * @return The replier's NRIC string, or null if not replied.
     */
    public String getRepliedByNric() {
        return repliedByNric;
    }

    /**
     * Gets the date the enquiry was submitted.
     * 
     * @return The enquiry submission date.
     */
    public Date getEnquiryDate() {
        return enquiryDate;
    }

    /**
     * Gets the date the reply was submitted, if any.
     * 
     * @return The reply submission date, or null if not replied.
     */
    public Date getReplyDate() {
        return replyDate;
    }

    /**
     * Sets the enquiry text. Can only be done if the enquiry has not yet been
     * replied to.
     * Ensures the new text is not null or empty.
     *
     * @param enquiryText The new enquiry text.
     * @return true if the text was successfully updated, false otherwise (already
     *         replied or invalid text).
     */
    public boolean setEnquiryText(String enquiryText) {
        if (!isReplied() && enquiryText != null && !enquiryText.trim().isEmpty()) {
            this.enquiryText = enquiryText.trim();
            return true;
        } else if (isReplied()) {
            System.err.println("Cannot edit an enquiry that has already been replied to (ID: " + enquiryId + ").");
            return false;
        } else {
            System.err.println("Enquiry text cannot be empty.");
            return false;
        }
    }

    /**
     * Sets the reply details for this enquiry.
     * Marks the enquiry as replied.
     * Ensures reply text, replier NRIC, and reply date are not null or empty.
     *
     * @param replyText     The text content of the reply.
     * @param repliedByNric The NRIC of the staff member providing the reply.
     * @param replyDate     The date the reply was submitted.
     * @return true if the reply details were successfully set, false otherwise
     *         (invalid parameters).
     */
    public boolean setReply(String replyText, String repliedByNric, Date replyDate) {
        if (replyText != null && !replyText.trim().isEmpty() && repliedByNric != null && replyDate != null) {
            this.replyText = replyText.trim();
            this.repliedByNric = repliedByNric;
            this.replyDate = replyDate;
            return true;
        } else {
            System.err.println("Invalid reply parameters provided for enquiry ID: " + enquiryId);
            return false;
        }
    }

    /**
     * Checks if this enquiry has been replied to.
     * An enquiry is considered replied if the `replyText` is not null and not
     * empty.
     *
     * @return true if the enquiry has a reply, false otherwise.
     */
    public boolean isReplied() {
        return this.replyText != null && !this.replyText.isEmpty();
    }
}
```

Controllers\EnquiryApplicantController.java (247)
```java
/**
 * Controller handling enquiry-related actions initiated by an Applicant (or an Officer acting as an Applicant),
 * such as submitting, viewing, editing, and deleting their own enquiries.
 * Requires an IEnquiryService.
 *
 * @author Kai Wang
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Models.Enquiry;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class EnquiryApplicantController extends BaseController {

    private final IEnquiryService enquiryService;

    /**
     * Constructs a new EnquiryApplicantController.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access.
     * @param currentUser                The currently logged-in User (expected to
     *                                   be Applicant or HDBOfficer).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public EnquiryApplicantController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        this.enquiryService = enquiryService;
    }

    /**
     * Allows the applicant to submit a new enquiry about a BTO project.
     * - Optionally displays a list of viewable projects for selection.
     * - Allows the applicant to type the project name directly if not selected or
     * if the project isn't listed.
     * - Prompts for the enquiry text.
     * - Creates a new Enquiry object.
     * - Adds the enquiry using the enquiry service and saves it.
     */
    public void submitEnquiry() {
        System.out.println("\n--- Submit Enquiry ---");
        List<Project> viewableProjects = getFilteredProjects(true, false, false, false, false);
        Project selectedProject = null;
        String projectNameInput;

        if (!viewableProjects.isEmpty()) {
            viewAndSelectProject(viewableProjects, "Select Project to Enquire About (Optional)");
            selectedProject = selectProjectFromList(viewableProjects);
        }

        if (selectedProject != null) {
            projectNameInput = selectedProject.getProjectName();
            System.out.println("Enquiring about project: " + projectNameInput);
        } else {
            if (!viewableProjects.isEmpty()) {
                System.out.println("No project selected from list, or you chose to cancel selection.");
            }
            System.out.print("Enter the exact Project Name you want to enquire about (leave blank to cancel): ");
            projectNameInput = scanner.nextLine().trim();

            if (projectNameInput.isEmpty()) {
                System.out.println("Enquiry cancelled.");
                return;
            }
            if (projectService.findProjectByName(projectNameInput) == null) {
                System.out.println("Warning: Project '" + projectNameInput
                        + "' not found in current listings. Ensure the name is correct before submitting.");
            }
        }

        System.out.print("Enter your enquiry text (cannot be empty): ");
        String text = scanner.nextLine().trim();

        if (!text.isEmpty()) {
            Enquiry newEnquiry = new Enquiry(currentUser.getNric(), projectNameInput, text, DateUtils.getCurrentDate());
            enquiryService.addEnquiry(newEnquiry);
            System.out.println("Enquiry submitted successfully (ID: " + newEnquiry.getEnquiryId() + ").");
            enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
        } else {
            System.out.println("Enquiry text cannot be empty. Enquiry not submitted.");
        }
    }

    /**
     * Displays all enquiries submitted by the currently logged-in applicant.
     * Retrieves enquiries using the enquiry service, sorts them by date (most
     * recent first).
     * Displays enquiry ID, project name, date, enquiry text, and reply details (if
     * replied).
     */
    public void viewMyEnquiries() {
        System.out.println("\n--- Your Enquiries ---");
        List<Enquiry> myEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .sorted(Comparator.comparing((Enquiry e) -> e.getEnquiryDate()).reversed())
                .collect(Collectors.toList());

        if (myEnquiries.isEmpty()) {
            System.out.println("You have not submitted any enquiries.");
            return;
        }

        for (int i = 0; i < myEnquiries.size(); i++) {
            Enquiry e = myEnquiries.get(i);
            System.out.printf("%d. ID: %s | Project: %s | Date: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), DateUtils.formatDate(e.getEnquiryDate()));
            System.out.println("   Enquiry: " + e.getEnquiryText());
            if (e.isReplied()) {
                System.out.printf("   Reply (by %s on %s): %s\n",
                        e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                        e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                        e.getReplyText());
            } else {
                System.out.println("   Reply: (Pending)");
            }
            System.out.println("----------------------------------------");
        }
    }

    /**
     * Allows the applicant to edit the text of their own submitted enquiries,
     * provided they have not yet been replied to.
     * - Retrieves and displays editable enquiries (own, not replied).
     * - Prompts the user to select an enquiry to edit.
     * - Prompts for the new enquiry text.
     * - Updates the enquiry text using the Enquiry object's setter method.
     * - Saves the changes via the enquiry service.
     */
    public void editMyEnquiry() {
        System.out.println("\n--- Edit Enquiry ---");
        List<Enquiry> editableEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .filter(e -> !e.isReplied())
                .sorted(Comparator.comparing((Enquiry e) -> e.getEnquiryDate()).reversed())
                .collect(Collectors.toList());

        if (editableEnquiries.isEmpty()) {
            System.out.println("You have no enquiries that can be edited (must not be replied to yet).");
            return;
        }

        System.out.println("Select enquiry to edit:");
        for (int i = 0; i < editableEnquiries.size(); i++) {
            Enquiry e = editableEnquiries.get(i);
            String truncatedText = e.getEnquiryText().length() > 50 ? e.getEnquiryText().substring(0, 47) + "..."
                    : e.getEnquiryText();
            System.out.printf("%d. ID: %s | Project: %s | Text: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), truncatedText);
        }

        int choice = getIntInput("Enter choice (or 0 to cancel): ", 0, editableEnquiries.size());

        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        Enquiry enquiryToEdit = editableEnquiries.get(choice - 1);
        System.out.println("Current text: " + enquiryToEdit.getEnquiryText());
        System.out.print("Enter new enquiry text (cannot be empty): ");
        String newText = scanner.nextLine().trim();

        if (enquiryToEdit.setEnquiryText(newText)) {
            System.out.println("Enquiry updated successfully.");
            enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
        } else {
            System.out.println("Enquiry not updated.");
        }
    }

    /**
     * Allows the applicant to delete their own submitted enquiries, provided they
     * have not yet been replied to.
     * - Retrieves and displays deletable enquiries (own, not replied).
     * - Prompts the user to select an enquiry to delete.
     * - Asks for confirmation.
     * - If confirmed, removes the enquiry using the enquiry service and saves the
     * changes.
     */
    public void deleteMyEnquiry() {
        System.out.println("\n--- Delete Enquiry ---");
        List<Enquiry> deletableEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .filter(e -> !e.isReplied())
                .sorted(Comparator.comparing((Enquiry e) -> e.getEnquiryDate()).reversed())
                .collect(Collectors.toList());

        if (deletableEnquiries.isEmpty()) {
            System.out.println("You have no enquiries that can be deleted (must not be replied to yet).");
            return;
        }

        System.out.println("Select enquiry to delete:");
        for (int i = 0; i < deletableEnquiries.size(); i++) {
            Enquiry e = deletableEnquiries.get(i);
            String truncatedText = e.getEnquiryText().length() > 50 ? e.getEnquiryText().substring(0, 47) + "..."
                    : e.getEnquiryText();
            System.out.printf("%d. ID: %s | Project: %s | Text: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), truncatedText);
        }

        int choice = getIntInput("Enter choice (or 0 to cancel): ", 0, deletableEnquiries.size());

        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        Enquiry enquiryToDelete = deletableEnquiries.get(choice - 1);
        System.out.print(
                "Are you sure you want to permanently delete enquiry " + enquiryToDelete.getEnquiryId()
                        + "? (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            if (enquiryService.removeEnquiry(enquiryToDelete.getEnquiryId())) {
                System.out.println("Enquiry deleted successfully.");
                enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
            } else {
                System.err.println("Error: Failed to remove enquiry from service layer.");
            }
        } else {
            System.out.println("Deletion cancelled.");
        }
    }
}
```

Controllers\BookingOfficerController.java (237)
```java
/**
 * Controller handling actions performed by an HDB Officer related to managing the flat booking process
 * for applicants whose applications have been approved (status SUCCESSFUL).
 * Inherits common functionality from BaseController.
 *
 * @author Patrick
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class BookingOfficerController extends BaseController {
    /**
     * Constructs a new BookingOfficerController.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param currentUser                The currently logged-in User (expected to
     *                                   be HDBOfficer).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public BookingOfficerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
    }

    /**
     * Guides the HDB Officer through the process of booking a flat for a selected
     * applicant.
     * - Checks if the officer is currently handling an active project.
     * - Retrieves and displays applicants for the handling project whose status is
     * SUCCESSFUL.
     * - Prompts the officer to select an applicant.
     * - Performs pre-booking checks:
     * - Verifies the application status is still SUCCESSFUL.
     * - Verifies the applicant profile doesn't already show them as BOOKED.
     * - Verifies the application has a valid flat type specified.
     * - Checks if units are still available for the applied flat type in the
     * project.
     * - Prompts for confirmation.
     * - If confirmed:
     * - Decrements the available unit count in the project's FlatTypeDetails.
     * - Updates the BTOApplication status to BOOKED.
     * - Updates the Applicant's profile status to BOOKED and sets the
     * bookedFlatType.
     * - Generates and displays a booking receipt.
     * - Saves the updated application, project (due to unit count change), and
     * potentially user data.
     */
    public void manageFlatBooking() {
        if (!(currentUser instanceof HDBOfficer))
            return;
        HDBOfficer officer = (HDBOfficer) currentUser;

        Project project = getOfficerHandlingProject(officer);

        if (project == null) {
            System.out.println("You need to be handling an active project to manage flat bookings.");
            return;
        }
        String handlingProjectName = project.getProjectName();

        System.out.println("\n--- Flat Booking Management for Project: " + handlingProjectName + " ---");

        List<BTOApplication> successfulApps = applicationService.getApplicationsByProject(handlingProjectName)
                .stream()
                .filter(app -> app.getStatus() == ApplicationStatus.SUCCESSFUL)
                .sorted(Comparator.comparing(app -> app.getApplicationDate()))
                .collect(Collectors.toList());

        if (successfulApps.isEmpty()) {
            System.out.println("No applicants with status SUCCESSFUL found for this project (ready for booking).");
            return;
        }

        System.out.println("Applicants with SUCCESSFUL status (ready for booking):");
        for (int i = 0; i < successfulApps.size(); i++) {
            BTOApplication app = successfulApps.get(i);
            User applicantUser = userService.findUserByNric(app.getApplicantNric());
            System.out.printf("%d. NRIC: %s | Name: %-15s | Applied Type: %-8s | App Date: %s\n",
                    i + 1,
                    app.getApplicantNric(),
                    applicantUser != null ? applicantUser.getName() : "N/A",
                    app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                    DateUtils.formatDate(app.getApplicationDate()));
        }

        int choice = getIntInput("Enter the number of the applicant to process booking for (or 0 to cancel): ", 0,
                successfulApps.size());

        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        BTOApplication applicationToBook = successfulApps.get(choice - 1);
        User applicantUser = userService.findUserByNric(applicationToBook.getApplicantNric());

        if (!(applicantUser instanceof Applicant)) {
            System.out.println(
                    "Error: Applicant data not found or invalid for NRIC " + applicationToBook.getApplicantNric()
                            + ". Cannot process booking.");
            return;
        }
        Applicant applicant = (Applicant) applicantUser;

        if (applicationToBook.getStatus() != ApplicationStatus.SUCCESSFUL) {
            System.out.println("Error: Applicant status is no longer SUCCESSFUL (Current: "
                    + applicationToBook.getStatus() + "). Cannot proceed with booking.");
            return;
        }
        if (applicant.hasBooked()) {
            System.out.println("Error: Applicant " + applicant.getNric()
                    + " has already booked a flat according to their profile. Booking cancelled.");
            return;
        }
        FlatType appliedFlatType = applicationToBook.getFlatTypeApplied();
        if (appliedFlatType == null) {
            System.out.println("Error: Application record does not have a valid flat type specified. Cannot book.");
            return;
        }
        Project currentProjectState = projectService.findProjectByName(handlingProjectName);
        if (currentProjectState == null) {
            System.out.println("Error: Could not retrieve current project state. Booking cancelled.");
            return;
        }
        FlatTypeDetails details = currentProjectState.getMutableFlatTypeDetails(appliedFlatType);
        if (details == null) {
            System.out.println("Error: Flat type details not found for " + appliedFlatType.getDisplayName()
                    + " in project " + currentProjectState.getProjectName() + ". Cannot book.");
            return;
        }
        if (details.getAvailableUnits() <= 0) {
            System.out.println("Error: No available units for the applied flat type ("
                    + appliedFlatType.getDisplayName() + ") at this moment. Booking cannot proceed.");
            return;
        }

        System.out.println("\n--- Confirm Booking ---");
        System.out.println("Applicant: " + applicant.getName() + " (" + applicant.getNric() + ")");
        System.out.println("Project: " + applicationToBook.getProjectName());
        System.out.println("Flat Type: " + appliedFlatType.getDisplayName());
        System.out.println("Available Units Before Booking: " + details.getAvailableUnits());
        System.out.printf("Selling Price: $%.2f\n", details.getSellingPrice());

        System.out.print("\nConfirm booking for this applicant? (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            if (!details.decrementAvailableUnits()) {
                System.out.println(
                        "Error: Failed to decrement unit count (Units might have just become zero). Booking cancelled.");
                return;
            }

            applicationToBook.setStatus(ApplicationStatus.BOOKED);

            applicant.setApplicationStatus(ApplicationStatus.BOOKED);
            applicant.setBookedFlatType(appliedFlatType);

            System.out.println("Booking confirmed successfully!");
            System.out.println("Applicant status updated to BOOKED.");
            System.out.println(
                    "Remaining units for " + appliedFlatType.getDisplayName() + ": " + details.getAvailableUnits());

            generateBookingReceipt(applicant, applicationToBook, currentProjectState);

            applicationService.saveApplications(applicationService.getAllApplications());
            projectService.saveProjects(projectService.getAllProjects());

        } else {
            System.out.println("Booking cancelled.");
        }
    }

    /**
     * Generates and displays a booking receipt for the applicant.
     * Displays the applicant's details, project details, and booking status.
     * 
     * @param applicant   The applicant whose booking receipt is being generated.
     * @param application The BTOApplication associated with the booking.
     * @param project     The project associated with the booking.
     */

    private void generateBookingReceipt(Applicant applicant, BTOApplication application, Project project) {
        System.out.println("\n================ BTO Booking Receipt ================");
        System.out.println(" Receipt Generated: " + DateUtils.formatDate(DateUtils.getCurrentDate()) + " by Officer "
                + currentUser.getNric());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Applicant Details:");
        System.out.println("   Name:          " + applicant.getName());
        System.out.println("   NRIC:          " + applicant.getNric());
        System.out.println("   Age:           " + applicant.getAge());
        System.out.println("   Marital Status:" + applicant.getMaritalStatus());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Booking Details:");
        System.out.println("   Project Name:  " + project.getProjectName());
        System.out.println("   Neighborhood:  " + project.getNeighborhood());
        System.out.println("   Booked Flat:   "
                + (application.getFlatTypeApplied() != null ? application.getFlatTypeApplied().getDisplayName()
                        : "N/A"));
        FlatTypeDetails details = project.getFlatTypeDetails(application.getFlatTypeApplied());
        if (details != null) {
            System.out.printf("   Selling Price: $%.2f\n", details.getSellingPrice());
        } else {
            System.out.println("   Selling Price: N/A");
        }
        System.out.println("   Booking Status:" + application.getStatus());
        System.out.println("   Application ID:" + application.getApplicationId());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Thank you for choosing HDB!");
        System.out.println("=====================================================");
    }
}
```

Services\DataService.java (237)
```java
/**
 * Provides static utility methods for coordinating data loading, synchronization, and saving across different services.
 * Handles initial data synchronization logic after loading and provides convenience methods for saving all data or just user data.
 *
 * @author Jordon
 */
package Services;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import Controllers.AuthController;

import java.util.Date;
import java.util.Comparator;
import java.io.File;

import Enums.OfficerRegistrationStatus;
import Enums.ApplicationStatus;

import Models.Project;
import Models.BTOApplication;
import Models.OfficerRegistration;
import Models.User;
import Models.Applicant;
import Models.HDBOfficer;

public class DataService {
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";

    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    private static final String[] APPLICANT_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] OFFICER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] MANAGER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };

    /**
     * Performs data synchronization checks and updates after initial loading.
     * - Synchronizes Applicant profile status (appliedProjectName,
     * applicationStatus, bookedFlatType) based on the latest relevant
     * BTOApplication record.
     * - Synchronizes Project approved officer lists with OfficerRegistration
     * records:
     * - Creates/updates APPROVED registrations if an officer is listed in a
     * project's CSV but lacks a corresponding registration.
     * - Issues warnings if an APPROVED registration exists but the officer is
     * missing from the project's CSV list.
     * - Note: Adjustment of project available units based on booked applications is
     * now handled within ApplicationService.loadApplications.
     * Saves officer registrations if any changes were made during synchronization.
     *
     * @param userService                The user service instance containing loaded
     *                                   user data.
     * @param projectService             The project service instance containing
     *                                   loaded project data.
     * @param applicationService         The application service instance containing
     *                                   loaded application data.
     * @param officerRegistrationService The officer registration service instance
     *                                   containing loaded registration data.
     */
    public static void synchronizeData(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService) {
        System.out.println("Synchronizing loaded data...");

        Map<String, User> users = userService.getAllUsers();
        List<Project> projects = projectService.getAllProjects();
        Map<String, BTOApplication> applications = applicationService.getAllApplications();
        Map<String, OfficerRegistration> officerRegistrations = officerRegistrationService.getAllRegistrations();

        boolean registrationsModified = false;

        users.values().stream()
                .filter(u -> u instanceof Applicant)
                .map(u -> (Applicant) u)
                .forEach(applicant -> {
                    BTOApplication relevantApp = applications.values().stream()
                            .filter(app -> app.getApplicantNric().equals(applicant.getNric()))
                            .max(Comparator.comparing((BTOApplication app) -> app.getStatus(),
                                    Comparator.comparingInt(s -> {
                                        switch (s) {
                                            case BOOKED:
                                                return 6;
                                            case SUCCESSFUL:
                                                return 5;
                                            case PENDING_WITHDRAWAL:
                                                return 4;
                                            case PENDING:
                                                return 3;
                                            case WITHDRAWN:
                                                return 2;
                                            case UNSUCCESSFUL:
                                                return 1;
                                            default:
                                                return 0;
                                        }
                                    })).thenComparing((BTOApplication app) -> app.getApplicationDate(),
                                            Comparator.reverseOrder()))
                            .orElse(null);

                    if (relevantApp != null) {
                        applicant.setAppliedProjectName(relevantApp.getProjectName());
                        applicant.setApplicationStatus(relevantApp.getStatus());
                        if (relevantApp.getStatus() == ApplicationStatus.BOOKED) {
                            applicant.setBookedFlatType(relevantApp.getFlatTypeApplied());
                        } else {
                            applicant.setBookedFlatType(null);
                        }
                    } else {
                        applicant.clearApplicationState();
                    }
                });

        for (Project project : projects) {
            List<String> approvedNricsFromProject = new ArrayList<>(project.getApprovedOfficerNrics());

            for (String officerNric : approvedNricsFromProject) {
                User user = users.get(officerNric);
                if (!(user instanceof HDBOfficer)) {
                    System.err.println("Data Sync Warning: NRIC " + officerNric + " in project '"
                            + project.getProjectName()
                            + "' approved list is not a valid HDB Officer. Consider removing from project CSV.");
                    continue;
                }

                String expectedRegId = officerNric + "_REG_" + project.getProjectName();
                OfficerRegistration existingReg = officerRegistrations.get(expectedRegId);

                if (existingReg == null || existingReg.getStatus() != OfficerRegistrationStatus.APPROVED) {
                    System.out.println("Info: Auto-creating/updating APPROVED registration for Officer " + officerNric
                            + " for Project '" + project.getProjectName() + "' based on project list.");

                    Date placeholderDate = project.getApplicationOpeningDate() != null
                            ? project.getApplicationOpeningDate()
                            : new Date(0);

                    OfficerRegistration syncReg = new OfficerRegistration(expectedRegId, officerNric,
                            project.getProjectName(), OfficerRegistrationStatus.APPROVED, placeholderDate);
                    officerRegistrations.put(syncReg.getRegistrationId(), syncReg);
                    registrationsModified = true;
                }
            }

            officerRegistrations.values().stream()
                    .filter(reg -> reg.getProjectName().equals(project.getProjectName())
                            && reg.getStatus() == OfficerRegistrationStatus.APPROVED)
                    .forEach(reg -> {
                        if (!project.getApprovedOfficerNrics().contains(reg.getOfficerNric())) {
                            System.err.println("Data Sync Warning: Approved registration " + reg.getRegistrationId()
                                    + " exists, but officer " + reg.getOfficerNric() + " is NOT in project '"
                                    + project.getProjectName()
                                    + "' approved list. Project CSV might be outdated or registration status incorrect.");
                        }
                    });
        }

        if (registrationsModified) {
            System.out.println("Saving updated officer registrations due to synchronization...");
            officerRegistrationService.saveOfficerRegistrations(officerRegistrations);
        }

        System.out.println("Data synchronization complete.");
    }

    /**
     * Saves all data managed by the provided services to their respective
     * persistent storage locations (CSV files).
     * This is a convenience method typically called during application shutdown.
     *
     * @param userService                The user service instance.
     * @param projectService             The project service instance.
     * @param applicationService         The application service instance.
     * @param enquiryService             The enquiry service instance.
     * @param officerRegistrationService The officer registration service instance.
     */
    public static void saveAllData(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IEnquiryService enquiryService,
            IOfficerRegistrationService officerRegistrationService) {
        System.out.println("Saving all data...");
        userService.saveUsers(userService.getAllUsers());
        projectService.saveProjects(projectService.getAllProjects());
        applicationService.saveApplications(applicationService.getAllApplications());
        enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
        officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
        System.out.println("All data saved.");
    }

    /**
     * Static method to save user data to respective CSV files (ApplicantList,
     * OfficerList, ManagerList).
     * This method duplicates the logic in {@link UserService#saveUsers(Map)} and is
     * kept primarily for compatibility
     * with {@link AuthController} which uses it directly. Ideally, AuthController
     * should use IUserService.
     *
     * @param users The map of users (NRIC to User object) to save.
     */
    public static void saveUsers(Map<String, User> users) {
        List<String[]> applicantData = new ArrayList<>();
        List<String[]> officerData = new ArrayList<>();
        List<String[]> managerData = new ArrayList<>();

        applicantData.add(APPLICANT_HEADER);
        officerData.add(OFFICER_HEADER);
        managerData.add(MANAGER_HEADER);

        users.values().forEach(user -> {
            String[] userData = {
                    user.getName(),
                    user.getNric(),
                    String.valueOf(user.getAge()),
                    user.getMaritalStatus().name(),
                    user.getPassword()
            };
            switch (user.getRole()) {
                case HDB_MANAGER:
                    managerData.add(userData);
                    break;
                case HDB_OFFICER:
                    officerData.add(userData);
                    break;
                case APPLICANT:
                    applicantData.add(userData);
                    break;
            }
        });

        CsvRW.writeCsv(APPLICANT_LIST_FILE, applicantData);
        CsvRW.writeCsv(OFFICER_LIST_FILE, officerData);
        CsvRW.writeCsv(MANAGER_LIST_FILE, managerData);
        System.out.println("Saved users (via static DataService method).");
    }
}
```

Controllers\WithdrawalManagerController.java (236)
```java
/**
 * Controller handling actions performed by an HDB Manager related to managing
 * BTO application withdrawal requests (status PENDING_WITHDRAWAL) for projects they manage.
 * Inherits common functionality from BaseController.
 *
 * @author Jordon
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;


public class WithdrawalManagerController extends BaseController {
/**
 * Constructs a new WithdrawalManagerController.
 * Ensures the current user is an HDBManager.
 *
 * @param userService Service for user data access.
 * @param projectService Service for project data access.
 * @param applicationService Service for application data access.
 * @param officerRegistrationService Service for officer registration data access.
 * @param enquiryService Service for enquiry data access.
 * @param currentUser The currently logged-in User (must be HDBManager).
 * @param scanner Scanner instance for reading user input.
 * @param authController Controller for authentication tasks.
 * @throws IllegalArgumentException if the currentUser is not an HDBManager.
 */
    public WithdrawalManagerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   IEnquiryService enquiryService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("WithdrawalManagerController requires an HDBManager user.");
        }
    }
/**
 * Guides the HDB Manager through approving or rejecting pending withdrawal requests for applications in their managed projects.
 * - Finds all applications with status PENDING_WITHDRAWAL for projects managed by the current manager.
 * - Displays these pending requests, showing applicant details and the inferred original status before withdrawal.
 * - Prompts the manager to select a request to process.
 * - Validates applicant and project data.
 * - Determines the original status (using stored value if available, otherwise inferring).
 * - Verifies the application is still in PENDING_WITHDRAWAL status.
 * - Prompts for Approve (A) or Reject (R) action.
 * - If Approve:
 *   - Determines the final status based on the original status (UNSUCCESSFUL if originally BOOKED/SUCCESSFUL, WITHDRAWN if originally PENDING).
 *   - If originally BOOKED, attempts to release the flat unit back to the project by incrementing available units in FlatTypeDetails.
 *   - Updates the application status to the final determined status.
 *   - Updates the applicant's profile status and clears their booked flat type.
 *   - Saves application data, and project data if a unit was released.
 * - If Reject:
 *   - Reverts the application status and the applicant's profile status back to the original status determined earlier.
 *   - Saves the application data.
 */
     public void manageWithdrawalRequests() {
        System.out.println("\n--- Manage Withdrawal Requests ---");
        List<String> myProjectNames = projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                .map((Project p) -> p.getProjectName())
                .collect(Collectors.toList());

        if (myProjectNames.isEmpty()) {
            System.out.println("You are not managing any projects to have withdrawal requests.");
            return;
        }

        List<BTOApplication> pendingWithdrawals = applicationService.getAllApplications().values().stream()
                .filter(app -> app.getStatus() == ApplicationStatus.PENDING_WITHDRAWAL)
                .filter(app -> myProjectNames.contains(app.getProjectName()))
                .sorted(Comparator.comparing((BTOApplication app) -> app.getApplicationDate()))
                .collect(Collectors.toList());

        if (pendingWithdrawals.isEmpty()) {
            System.out.println("No pending withdrawal requests found for the projects you manage.");
            return;
        }

        System.out.println("--- Pending Withdrawal Requests ---");
        for (int i = 0; i < pendingWithdrawals.size(); i++) {
            BTOApplication app = pendingWithdrawals.get(i);
            User applicantUser = userService.findUserByNric(app.getApplicantNric());

            ApplicationStatus statusBefore = app.getStatusBeforeWithdrawal();
            if (statusBefore == null) {
                 statusBefore = inferStatusBeforeWithdrawal(app, (applicantUser instanceof Applicant) ? (Applicant) applicantUser : null);
                 System.out.print(" (Inferred Original: " + statusBefore + ")");
            } else {
                System.out.print(" (Original: " + statusBefore + ")");
            }

            System.out.printf("\n%d. NRIC: %s | Name: %-15s | Project: %-15s | Type: %-8s | App Date: %s",
                    i + 1,
                    app.getApplicantNric(),
                    applicantUser != null ? applicantUser.getName() : "N/A",
                    app.getProjectName(),
                    app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                    DateUtils.formatDate(app.getApplicationDate()));
            System.out.println();
        }

        int choice = getIntInput("Enter number to Approve/Reject withdrawal (or 0 to skip): ", 0, pendingWithdrawals.size());

        if (choice >= 1) {
            BTOApplication appToProcess = pendingWithdrawals.get(choice - 1);
            User applicantUser = userService.findUserByNric(appToProcess.getApplicantNric());

            if (!(applicantUser instanceof Applicant)) {
                System.out.println("Error: Applicant data not found or invalid for NRIC "
                        + appToProcess.getApplicantNric() + ". Cannot process withdrawal.");
                return;
            }
            Applicant applicant = (Applicant) applicantUser;

            Project project = projectService.findProjectByName(appToProcess.getProjectName());
            if (project == null) {
                System.out.println("Error: Project data not found for application "
                        + appToProcess.getApplicationId() + ". Cannot process withdrawal.");
                return;
            }

            ApplicationStatus originalStatus = appToProcess.getStatusBeforeWithdrawal();
            if (originalStatus == null) {
                originalStatus = inferStatusBeforeWithdrawal(appToProcess, applicant);
                 System.out.println("Note: Original status inferred as " + originalStatus + " due to missing data.");
            }

             if (appToProcess.getStatus() != ApplicationStatus.PENDING_WITHDRAWAL) {
                  System.out.println("Error: Application status is no longer PENDING_WITHDRAWAL (Current: " + appToProcess.getStatus() + "). Cannot process.");
                  return;
             }


            System.out.print("Approve or Reject withdrawal request for Applicant " + applicant.getName() + "? (A/R): ");
            String action = scanner.nextLine().trim().toUpperCase();

            if (action.equals("A")) {
                ApplicationStatus finalStatus;
                boolean releasedUnit = false;

                if (originalStatus == ApplicationStatus.BOOKED) {
                    finalStatus = ApplicationStatus.UNSUCCESSFUL;
                    FlatType bookedType = appToProcess.getFlatTypeApplied();
                    if (bookedType != null) {
                        FlatTypeDetails details = project.getMutableFlatTypeDetails(bookedType);
                        if (details != null) {
                            if (details.incrementAvailableUnits()) {
                                releasedUnit = true;
                                System.out.println("Unit for " + bookedType.getDisplayName()
                                        + " released back to project " + project.getProjectName() + ". Available: " + details.getAvailableUnits());
                            } else {
                                System.err.println("Error: Could not increment available units for " + bookedType.getDisplayName() + " (already at max?). Check data consistency.");
                            }
                        } else {
                            System.err.println("Error: Could not find flat details for " + bookedType.getDisplayName() + " during withdrawal approval.");
                        }
                    } else {
                        System.err.println("Error: Cannot determine booked flat type to release unit during withdrawal approval.");
                    }
                } else if (originalStatus == ApplicationStatus.SUCCESSFUL) {
                    finalStatus = ApplicationStatus.UNSUCCESSFUL;
                } else {
                    finalStatus = ApplicationStatus.WITHDRAWN;
                }

                appToProcess.setStatus(finalStatus);

                applicant.setApplicationStatus(finalStatus);
                applicant.setBookedFlatType(null);

                System.out.println("Withdrawal request Approved. Application status set to " + finalStatus + ".");

                applicationService.saveApplications(applicationService.getAllApplications());
                if (releasedUnit) {
                    projectService.saveProjects(projectService.getAllProjects());
                }

            } else if (action.equals("R")) {
                appToProcess.setStatus(originalStatus);

                applicant.setApplicationStatus(originalStatus);

                System.out.println("Withdrawal request Rejected. Application status reverted to " + originalStatus + ".");
                applicationService.saveApplications(applicationService.getAllApplications());

            } else {
                System.out.println("Invalid action ('A' or 'R' expected). No change made.");
            }
        } else if (choice != 0) {
            System.out.println("Invalid choice.");
        }
    }

    /**
     * Infers the application status before withdrawal based on the current application and applicant data.
     *
     * @param app The BTOApplication object representing the application.
     * @param applicant The Applicant object representing the applicant.
     * @return The inferred ApplicationStatus before withdrawal.
     */
    /** 
     * @param app
     * @param applicant
     * @return
     */
    private ApplicationStatus inferStatusBeforeWithdrawal(BTOApplication app, Applicant applicant) {
         if (applicant != null && applicant.hasBooked() && applicant.getBookedFlatType() == app.getFlatTypeApplied()) {
             return ApplicationStatus.BOOKED;
         }
         else if (applicant != null && applicant.getApplicationStatus() == ApplicationStatus.SUCCESSFUL && applicant.getAppliedProjectName().equals(app.getProjectName())) {
              return ApplicationStatus.SUCCESSFUL;
         }
         else if (app.getFlatTypeApplied() != null) {
              return ApplicationStatus.SUCCESSFUL;
         }
         return ApplicationStatus.PENDING;
    }
}
```

Controllers\ApplicationManagerController.java (230)
```java
/**
 * Controller handling actions performed by an HDB Manager related to managing
 * BTO applications submitted for the projects they manage (Approving or Rejecting PENDING applications).
 * Inherits common functionality from BaseController.
 *
 * @author Jordon
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class ApplicationManagerController extends BaseController {
    /**
     * Constructs a new ApplicationManagerController.
     * Ensures the current user is an HDBManager.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access.
     * @param currentUser                The currently logged-in User (must be
     *                                   HDBManager).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     * @throws IllegalArgumentException if the currentUser is not an HDBManager.
     */
    public ApplicationManagerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("ApplicationManagerController requires an HDBManager user.");
        }
    }

    /**
     * Guides the HDB Manager through approving or rejecting pending BTO
     * applications for a selected managed project.
     * - Displays a list of projects managed by the current manager for selection.
     * - Retrieves and displays PENDING applications for the selected project.
     * - Prompts the manager to select a pending application to process.
     * - Validates that the applicant data is available.
     * - Prompts for Approve (A) or Reject (R) action.
     * - If Approve:
     * - Checks if the application has a valid flat type specified.
     * - Checks if approving this application would exceed the total units available
     * for that flat type (considering already SUCCESSFUL or BOOKED applications).
     * - If checks pass, updates the application status and the applicant's profile
     * status to SUCCESSFUL, then saves the application data.
     * - If checks fail (e.g., no units left), informs the manager and does not
     * approve.
     * - If Reject:
     * - Updates the application status and the applicant's profile status to
     * UNSUCCESSFUL, clears booked flat type on profile, then saves the application
     * data.
     * - Displays a summary of applications with other statuses (Successful, Booked,
     * etc.) for the project.
     */
    public void manageApplications() {
        System.out.println("\n--- Manage BTO Applications ---");
        List<Project> myProjects = projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                .sorted(Comparator.comparing(project -> project.getProjectName()))
                .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects for which to manage applications.");
            return;
        }

        System.out.println("Select project to manage applications for:");
        viewAndSelectProject(myProjects, "Select Project");
        Project selectedProject = selectProjectFromList(myProjects);
        if (selectedProject == null)
            return;

        System.out.println("\n--- Applications for Project: " + selectedProject.getProjectName() + " ---");

        List<BTOApplication> projectApplications = applicationService
                .getApplicationsByProject(selectedProject.getProjectName())
                .stream()
                .sorted(Comparator.comparing(app -> app.getApplicationDate()))
                .collect(Collectors.toList());

        if (projectApplications.isEmpty()) {
            System.out.println("No applications found for this project.");
            return;
        }

        List<BTOApplication> pendingApps = projectApplications.stream()
                .filter(app -> app.getStatus() == ApplicationStatus.PENDING)
                .collect(Collectors.toList());

        System.out.println("--- Pending Applications ---");
        if (pendingApps.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < pendingApps.size(); i++) {
                BTOApplication app = pendingApps.get(i);
                User applicantUser = userService.findUserByNric(app.getApplicantNric());
                System.out.printf("%d. NRIC: %s | Name: %-15s | Type: %-8s | Date: %s\n",
                        i + 1, app.getApplicantNric(),
                        applicantUser != null ? applicantUser.getName() : "N/A",
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                        DateUtils.formatDate(app.getApplicationDate()));
            }

            int choice = getIntInput("Enter number to Approve/Reject (or 0 to skip): ", 0, pendingApps.size());

            if (choice >= 1) {
                BTOApplication appToProcess = pendingApps.get(choice - 1);
                User applicantUser = userService.findUserByNric(appToProcess.getApplicantNric());

                if (!(applicantUser instanceof Applicant)) {
                    System.out.println("Error: Applicant data not found or invalid for NRIC "
                            + appToProcess.getApplicantNric() + ". Rejecting application.");
                    appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                    applicationService.saveApplications(applicationService.getAllApplications());
                    return;
                }
                Applicant applicant = (Applicant) applicantUser;

                System.out.print("Approve or Reject application for Applicant " + applicant.getName() + "? (A/R): ");
                String action = scanner.nextLine().trim().toUpperCase();

                if (action.equals("A")) {
                    FlatType appliedType = appToProcess.getFlatTypeApplied();
                    if (appliedType == null) {
                        System.out.println("Error: Application has no specified flat type. Cannot approve. Rejecting.");
                        appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicationService.saveApplications(applicationService.getAllApplications());
                        return;
                    }

                    Project currentProjectState = projectService.findProjectByName(selectedProject.getProjectName());
                    if (currentProjectState == null) {
                        System.out.println("Error: Project details not found. Cannot approve. Rejecting.");
                        appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicationService.saveApplications(applicationService.getAllApplications());
                        return;
                    }
                    FlatTypeDetails details = currentProjectState.getFlatTypeDetails(appliedType);

                    if (details == null) {
                        System.out.println("Error: Applied flat type (" + appliedType.getDisplayName()
                                + ") does not exist in this project configuration. Rejecting application.");
                        appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicationService.saveApplications(applicationService.getAllApplications());
                        return;
                    }

                    long alreadySuccessfulOrBookedCount = applicationService
                            .getApplicationsByProject(currentProjectState.getProjectName())
                            .stream()
                            .filter(a -> a.getFlatTypeApplied() == appliedType &&
                                    (a.getStatus() == ApplicationStatus.SUCCESSFUL
                                            || a.getStatus() == ApplicationStatus.BOOKED))
                            .count();

                    if (alreadySuccessfulOrBookedCount < details.getTotalUnits()) {
                        appToProcess.setStatus(ApplicationStatus.SUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.SUCCESSFUL);
                        System.out.println(
                                "Application Approved (Status: SUCCESSFUL). Applicant can now book via Officer.");
                        applicationService.saveApplications(applicationService.getAllApplications());
                    } else {
                        System.out.println("Cannot approve. The number of successful/booked applications ("
                                + alreadySuccessfulOrBookedCount + ") already meets or exceeds the total supply ("
                                + details.getTotalUnits() + ") for " + appliedType.getDisplayName() + ".");
                        System.out.println(
                                "Consider rejecting this application or managing existing successful/booked ones.");
                    }

                } else if (action.equals("R")) {
                    appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                    applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
                    applicant.setBookedFlatType(null);
                    System.out.println("Application Rejected (Status: UNSUCCESSFUL).");
                    applicationService.saveApplications(applicationService.getAllApplications());
                } else {
                    System.out.println("Invalid action ('A' or 'R' expected). No change made.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
        }

        System.out.println("\n--- Other Application Statuses ---");
        List<BTOApplication> otherApps = projectApplications.stream()
                .filter(app -> app.getStatus() != ApplicationStatus.PENDING)
                .collect(Collectors.toList());

        if (otherApps.isEmpty()) {
            System.out.println("(None)");
        } else {
            otherApps.forEach(app -> {
                User applicant = userService.findUserByNric(app.getApplicantNric());
                System.out.printf("- NRIC: %s | Name: %-15s | Type: %-8s | Status: %s\n",
                        app.getApplicantNric(),
                        applicant != null ? applicant.getName() : "N/A",
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                        app.getStatus());
            });
        }
    }
}
```

Controllers\OfficerRegistrationManagerController.java (227)
```java
/**
 * Controller handling actions performed by an HDB Manager related to managing
 * HDB Officer registration requests for projects (Approving or Rejecting).
 * Inherits common functionality from BaseController.
 *
 * @author Jordon
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.OfficerRegistrationStatus;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class OfficerRegistrationManagerController extends BaseController {
    /**
     * Constructs a new OfficerRegistrationManagerController.
     * Ensures the current user is an HDBManager.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access.
     * @param currentUser                The currently logged-in User (must be
     *                                   HDBManager).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     * @throws IllegalArgumentException if the currentUser is not an HDBManager.
     */
    public OfficerRegistrationManagerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("OfficerRegistrationManagerController requires an HDBManager user.");
        }
    }

    /**
     * Guides the HDB Manager through approving or rejecting pending officer
     * registrations for a selected managed project.
     * - Displays a list of projects managed by the current manager for selection.
     * - Shows the officer slot usage for the selected project.
     * - Retrieves and displays PENDING officer registrations for the selected
     * project.
     * - Prompts the manager to select a pending registration to process.
     * - Validates that the registering user is still a valid HDB Officer.
     * - Prompts for Approve (A) or Reject (R) action.
     * - If Approve:
     * - Checks if there are remaining officer slots in the project.
     * - Checks if the officer is already handling another project with overlapping
     * dates.
     * - If checks pass, calls a helper method (`approveOfficerRegistration`) to
     * update the registration status to APPROVED, add the officer to the project's
     * approved list, and save both registration and project data.
     * - If Reject:
     * - Updates the registration status to REJECTED and saves the registration
     * data.
     * - Displays lists of currently approved officers and rejected registrations
     * for the project.
     */
    public void manageOfficerRegistrations() {
        System.out.println("\n--- Manage HDB Officer Registrations ---");
        List<Project> myProjects = projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                .sorted(Comparator.comparing((Project p) -> p.getProjectName()))
                .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects for which to manage registrations.");
            return;
        }

        System.out.println("Select project to manage registrations for:");
        viewAndSelectProject(myProjects, "Select Project");
        Project selectedProject = selectProjectFromList(myProjects);
        if (selectedProject == null)
            return;

        System.out.println("\n--- Registrations for Project: " + selectedProject.getProjectName() + " ---");
        System.out.println("Officer Slots: " + selectedProject.getApprovedOfficerNrics().size() + " / "
                + selectedProject.getMaxOfficerSlots() + " (Remaining: " + selectedProject.getRemainingOfficerSlots()
                + ")");

        List<OfficerRegistration> projectRegistrations = officerRegistrationService
                .getRegistrationsByProject(selectedProject.getProjectName())
                .stream()
                .sorted(Comparator.comparing((OfficerRegistration oR) -> oR.getRegistrationDate()))
                .collect(Collectors.toList());

        List<OfficerRegistration> pendingRegistrations = projectRegistrations.stream()
                .filter(reg -> reg.getStatus() == OfficerRegistrationStatus.PENDING)
                .collect(Collectors.toList());

        System.out.println("\n--- Pending Registrations ---");
        if (pendingRegistrations.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < pendingRegistrations.size(); i++) {
                OfficerRegistration reg = pendingRegistrations.get(i);
                User officerUser = userService.findUserByNric(reg.getOfficerNric());
                System.out.printf("%d. NRIC: %s | Name: %-15s | Date: %s\n",
                        i + 1, reg.getOfficerNric(),
                        officerUser != null ? officerUser.getName() : "N/A",
                        DateUtils.formatDate(reg.getRegistrationDate()));
            }

            int choice = getIntInput("Enter number to Approve/Reject (or 0 to skip): ", 0, pendingRegistrations.size());

            if (choice >= 1) {
                OfficerRegistration regToProcess = pendingRegistrations.get(choice - 1);
                User officerUser = userService.findUserByNric(regToProcess.getOfficerNric());

                if (!(officerUser instanceof HDBOfficer)) {
                    System.out.println("Error: User " + regToProcess.getOfficerNric()
                            + " is no longer a valid HDB Officer. Rejecting registration.");
                    regToProcess.setStatus(OfficerRegistrationStatus.REJECTED);
                    officerRegistrationService
                            .saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
                    return;
                }
                HDBOfficer officer = (HDBOfficer) officerUser;

                System.out.print("Approve or Reject registration for Officer " + officer.getName() + "? (A/R): ");
                String action = scanner.nextLine().trim().toUpperCase();

                if (action.equals("A")) {
                    if (selectedProject.getRemainingOfficerSlots() <= 0) {
                        System.out.println("Cannot approve. No remaining officer slots for this project.");
                    } else if (isOfficerHandlingOverlappingProject(officer, selectedProject)) {
                        System.out.println(
                                "Cannot approve. Officer is already handling another project with overlapping dates.");
                    } else {
                        approveOfficerRegistration(regToProcess, selectedProject, officer);
                    }
                } else if (action.equals("R")) {
                    regToProcess.setStatus(OfficerRegistrationStatus.REJECTED);
                    System.out.println("Registration Rejected for Officer " + officer.getName() + ".");
                    officerRegistrationService
                            .saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
                } else {
                    System.out.println("Invalid action ('A' or 'R' expected). No change made.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
        }

        System.out.println("\n--- Approved Officers for this Project ---");
        List<String> approvedNrics = selectedProject.getApprovedOfficerNrics();
        if (approvedNrics.isEmpty()) {
            System.out.println("(None)");
        } else {
            approvedNrics.forEach(nric -> {
                User user = userService.findUserByNric(nric);
                System.out.println(
                        "- NRIC: " + nric + (user != null ? " (Name: " + user.getName() + ")" : " (Name: N/A)"));
            });
        }

        System.out.println("\n--- Rejected Registrations for this Project ---");
        List<OfficerRegistration> rejected = projectRegistrations.stream()
                .filter(r -> r.getStatus() == OfficerRegistrationStatus.REJECTED)
                .collect(Collectors.toList());
        if (rejected.isEmpty()) {
            System.out.println("(None)");
        } else {
            rejected.forEach(reg -> {
                User user = userService.findUserByNric(reg.getOfficerNric());
                System.out.println("- NRIC: " + reg.getOfficerNric()
                        + (user != null ? " (Name: " + user.getName() + ")" : " (Name: N/A)")
                        + " | Rejected on/after: " + DateUtils.formatDate(reg.getRegistrationDate()));
            });
        }
    }

    private boolean isOfficerHandlingOverlappingProject(HDBOfficer officer, Project targetProject) {
        return officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                .stream()
                .filter(reg -> reg.getStatus() == OfficerRegistrationStatus.APPROVED)
                .filter(reg -> !reg.getProjectName().equals(targetProject.getProjectName()))
                .map(reg -> projectService.findProjectByName(reg.getProjectName()))
                .filter(otherProject -> otherProject != null)
                .anyMatch(otherProject -> checkDateOverlap(targetProject, otherProject));
    }

    /**
     * Approves the officer registration for the given project and officer.
     * @param registration The officer registration to approve.
     * @param project The project to which the officer is being added.
     * @param officer The officer being approved.
     */
    private void approveOfficerRegistration(OfficerRegistration registration, Project project, HDBOfficer officer) {
        if (project.getRemainingOfficerSlots() <= 0) {
            System.out.println("Error: No remaining officer slots. Approval cannot proceed.");
            return;
        }

        if (project.addApprovedOfficer(registration.getOfficerNric())) {
            registration.setStatus(OfficerRegistrationStatus.APPROVED);
            System.out.println("Registration Approved. Officer " + registration.getOfficerNric() + " ("
                    + officer.getName() + ") added to project '" + project.getProjectName() + "'.");

            officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
            projectService.saveProjects(projectService.getAllProjects());
        } else {
            System.err.println("Error: Failed to add officer " + registration.getOfficerNric() + " to project '"
                    + project.getProjectName() + "' approved list (Slots full or already added?). Approval aborted.");
        }
    }
}
```

Controllers\ReportManagerController.java (223)
```java
/**
 * Controller handling the generation of reports requested by an HDB Manager.
 * Currently implements a report for applicants with booked flats, allowing various filters.
 * Inherits common functionality from BaseController.
 *
 * @author Jun Yang
 */
package Controllers;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.MaritalStatus;
import Models.BTOApplication;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

public class ReportManagerController extends BaseController {
    /**
     * Constructs a new ReportManagerController.
     * Ensures the current user is an HDBManager.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access.
     * @param currentUser                The currently logged-in User (must be
     *                                   HDBManager).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     * @throws IllegalArgumentException if the currentUser is not an HDBManager.
     */
    public ReportManagerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("ReportManagerController requires an HDBManager user.");
        }
    }

    /**
     * Generates and displays a report listing applicants who have booked flats,
     * based on manager-defined filters.
     * - Prompts the manager to filter by:
     * - Project Scope: All managed projects (respecting view filters) or a specific
     * managed project.
     * - Flat Type: Specific type or all.
     * - Marital Status: Specific status or all.
     * - Age Range: Minimum and/or maximum age, or none.
     * - Retrieves all applications with BOOKED status.
     * - Filters these applications based on the selected project(s), flat type, and
     * applicant demographics (marital status, age) by fetching user details.
     * - Sorts the results (e.g., by project name, then applicant NRIC).
     * - Displays the filtered list in a formatted table, showing applicant NRIC,
     * name, age, marital status, project name, and booked flat type.
     * - Shows the total count of matching applicants.
     */
    public void generateApplicantReport() {
        System.out.println("\n--- Generate Applicant Report (Booked Flats) ---");

        System.out.println("Filter by project:");
        System.out.println("1. All Projects Managed By You (Respecting View Filters)");
        System.out.println("2. A Specific Project Managed By You");
        System.out.println("0. Cancel");
        int projectFilterChoice = getIntInput("Enter choice: ", 0, 2);

        List<Project> projectsToReportOn = new ArrayList<>();
        if (projectFilterChoice == 0)
            return;

        if (projectFilterChoice == 1) {
            projectsToReportOn = getManagedProjectsApplyingFilters();
            if (projectsToReportOn.isEmpty()) {
                return;
            }
            System.out.println("Reporting on all projects you manage"
                    + (filterLocation != null || filterFlatType != null ? " (matching current view filters)." : "."));
        } else {
            List<Project> allMyProjects = projectService.getProjectsManagedBy(currentUser.getNric());
            if (allMyProjects.isEmpty()) {
                System.out.println("You are not managing any projects.");
                return;
            }
            viewAndSelectProject(allMyProjects.stream().sorted(Comparator.comparing((Project p) -> p.getProjectName()))
                    .collect(Collectors.toList()), "Select Specific Project to Report On");
            Project specificProject = selectProjectFromList(allMyProjects);
            if (specificProject == null)
                return;
            projectsToReportOn.add(specificProject);
            System.out.println("Reporting specifically for project: " + specificProject.getProjectName());
        }

        final List<String> finalProjectNames = projectsToReportOn.stream()
                .map((Project p) -> p.getProjectName())
                .collect(Collectors.toList());

        System.out.print("Filter report by Flat Type (TWO_ROOM, THREE_ROOM, or leave blank for all): ");
        String typeStr = scanner.nextLine().trim();
        FlatType filterReportFlatType = null;
        if (!typeStr.isEmpty()) {
            filterReportFlatType = FlatType.fromString(typeStr);
            if (filterReportFlatType != null) {
                System.out.println("Filtering report for flat type: " + filterReportFlatType.getDisplayName());
            } else {
                System.out.println("Invalid flat type entered. Reporting for all types.");
            }
        }

        System.out.print("Filter report by Marital Status (SINGLE, MARRIED, or leave blank for all): ");
        String maritalStr = scanner.nextLine().trim().toUpperCase();
        MaritalStatus filterMaritalStatus = null;
        if (!maritalStr.isEmpty()) {
            try {
                filterMaritalStatus = MaritalStatus.valueOf(maritalStr);
                System.out.println("Filtering report for marital status: " + filterMaritalStatus);
            } catch (IllegalArgumentException e) {
                System.out.println("Invalid marital status. Reporting for all statuses.");
            }
        }

        int minAge = getIntInput("Filter report by Minimum Age (e.g., 21, or 0 for no minimum): ", 0, 120);
        int maxAge = getIntInput("Filter report by Maximum Age (e.g., 65, or 0 for no maximum): ", 0, 120);
        if (minAge > 0 || maxAge > 0) {
            System.out.println("Filtering report for age range: "
                    + (minAge > 0 ? minAge : "Any") + " to "
                    + (maxAge > 0 ? maxAge : "Any"));
        }
        if (minAge > 0 && maxAge > 0 && maxAge < minAge) {
            System.out.println("Warning: Maximum age cannot be less than minimum age. Ignoring age filters.");
            minAge = 0;
            maxAge = 0;
        }

        final FlatType finalFilterReportFlatType = filterReportFlatType;
        final MaritalStatus finalFilterMaritalStatus = filterMaritalStatus;
        final int finalMinAge = minAge;
        final int finalMaxAge = maxAge;

        List<BTOApplication> bookedApplications = applicationService.getAllApplications().values().stream()
                .filter(app -> app.getStatus() == ApplicationStatus.BOOKED)
                .filter(app -> finalProjectNames.contains(app.getProjectName()))
                .filter(app -> finalFilterReportFlatType == null
                        || app.getFlatTypeApplied() == finalFilterReportFlatType)
                .filter(app -> {
                    User user = userService.findUserByNric(app.getApplicantNric());
                    if (user == null)
                        return false;

                    if (finalFilterMaritalStatus != null && user.getMaritalStatus() != finalFilterMaritalStatus)
                        return false;
                    if (finalMinAge > 0 && user.getAge() < finalMinAge)
                        return false;
                    if (finalMaxAge > 0 && user.getAge() > finalMaxAge)
                        return false;

                    return true;
                })
                .sorted(Comparator.comparing((BTOApplication app) -> app.getProjectName())
                        .thenComparing(app -> app.getApplicantNric()))
                .collect(Collectors.toList());

        System.out.println("\n--- Report: Applicants with Flat Bookings ---");
        System.out.println("Filters Applied: Projects=" + String.join(", ", finalProjectNames)
                + ", FlatType="
                + (finalFilterReportFlatType == null ? "Any" : finalFilterReportFlatType.getDisplayName())
                + ", MaritalStatus=" + (finalFilterMaritalStatus == null ? "Any" : finalFilterMaritalStatus)
                + ", Age=" + (finalMinAge > 0 ? finalMinAge : "Any") + "-" + (finalMaxAge > 0 ? finalMaxAge : "Any"));
        System.out.println("---------------------------------------------------------------------------------");
        System.out.printf("%-15s | %-15s | %-5s | %-10s | %-15s | %-8s\n",
                "Applicant NRIC", "Name", "Age", "Marital", "Project Name", "FlatType");
        System.out.println("---------------------------------------------------------------------------------");

        if (bookedApplications.isEmpty()) {
            System.out.println("No matching booked applications found for the specified filters.");
        } else {
            bookedApplications.forEach(app -> {
                User user = userService.findUserByNric(app.getApplicantNric());
                System.out.printf("%-15s | %-15s | %-5s | %-10s | %-15s | %-8s\n",
                        app.getApplicantNric(),
                        user != null ? user.getName() : "N/A",
                        user != null ? String.valueOf(user.getAge()) : "N/A",
                        user != null ? user.getMaritalStatus().name() : "N/A",
                        app.getProjectName(),
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A");
            });
        }
        System.out.println("---------------------------------------------------------------------------------");
        System.out.println("Total matching booked applicants: " + bookedApplications.size());
        System.out.println("--- End of Report ---");
    }

    /**
     * Retrieves the list of projects managed by the current user, applying any
     * active filters.
     * 
     * @return A list of projects managed by the current user, filtered by location
     *         and flat type.
     */
    private List<Project> getManagedProjectsApplyingFilters() {
        return projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                .sorted(Comparator.comparing((Project p) -> p.getProjectName()))
                .collect(Collectors.toList());
    }
}
```

Services\EnquiryService.java (220)
```java
/**
 * Service implementation for managing Enquiry data.
 * Handles loading enquiry data from enquiries.csv, managing unique ID generation,
 * and saving enquiries back. Provides methods for finding, retrieving, adding, and removing enquiries.
 *
 * @author Jordon
 */
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import Models.Enquiry;
import Parsers.Dparse;
import Utils.DateUtils;

public class EnquiryService implements IEnquiryService {
    private static final String DATA_DIR = "data";
    private static final String DELIMITER = ",";
    private static final String ENQUIRY_FILE = DATA_DIR + File.separator + "enquiries.csv";
    private static final String[] ENQUIRY_HEADER = { "EnquiryID", "ApplicantNRIC", "ProjectName", "EnquiryText",
            "ReplyText", "RepliedByNRIC", "EnquiryDate", "ReplyDate" };

    private List<Enquiry> enquiries;

    /**
     * Constructs a new EnquiryService. Initializes the internal enquiry list.
     */
    public EnquiryService() {
        this.enquiries = new ArrayList<>();
    }

    /**
     * Loads enquiry data from enquiries.csv.
     * Validates enquiry IDs (uniqueness), dates, and required fields (text, date).
     * Updates the static `nextId` in the Enquiry class based on loaded IDs to
     * ensure future generated IDs are unique.
     * Populates the internal enquiry list.
     *
     * @return A copy of the list containing all loaded enquiries.
     */
    @Override
    public List<Enquiry> loadEnquiries() {
        this.enquiries.clear();
        Set<String> enquiryIds = new HashSet<>();

        CsvRW.readCsv(ENQUIRY_FILE, ENQUIRY_HEADER.length).forEach(data -> {
            try {
                String id = data[0].trim();
                if (id.isEmpty() || !enquiryIds.add(id)) {
                    if (!id.isEmpty())
                        System.err.println("Skipping duplicate enquiry ID: " + id);
                    return;
                }
                String applicantNric = data[1].trim();
                String projectName = data[2].trim();
                String text = data[3].trim();
                String reply = data[4].trim();
                String repliedBy = data[5].trim();
                Date enqDate = Dparse.parseDate(data[6].trim());
                Date replyDate = Dparse.parseDate(data[7].trim());

                if (text.isEmpty() || enqDate == null) {
                    System.err.println("Skipping enquiry with missing text or invalid date: " + id);
                    enquiryIds.remove(id);
                    return;
                }
                if ((reply != null && !reply.isEmpty())
                        && (repliedBy == null || repliedBy.isEmpty() || replyDate == null)) {
                    System.err.println("Warning: Enquiry " + id
                            + " seems replied but missing replier NRIC or reply date. Loading reply as is.");
                }

                Enquiry enquiry = new Enquiry(id, applicantNric, projectName, text, reply, repliedBy, enqDate,
                        replyDate);
                this.enquiries.add(enquiry);
            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in enquiry data: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
            } catch (Exception e) {
                System.err.println(
                        "Error parsing enquiry data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });
        Enquiry.finalizeNextIdInitialization();
        System.out.println("Loaded " + this.enquiries.size() + " enquiries.");
        return new ArrayList<>(this.enquiries);
    }

    /**
     * Saves the provided list of enquiries to enquiries.csv.
     * Formats enquiry data, including handling null reply fields, for CSV storage.
     * Overwrites the existing file. Updates the internal enquiry list to match the
     * saved state.
     *
     * @param enquiriesToSave The list of Enquiry objects to save.
     */
    @Override
    public void saveEnquiries(List<Enquiry> enquiriesToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(ENQUIRY_HEADER);
        enquiriesToSave.stream()
                .sorted(Comparator.comparing((Enquiry e) -> e.getEnquiryId()))
                .forEach(enq -> {
                    dataList.add(new String[] {
                            enq.getEnquiryId(),
                            enq.getApplicantNric(),
                            enq.getProjectName(),
                            enq.getEnquiryText(),
                            enq.getReplyText() == null ? "" : enq.getReplyText(),
                            enq.getRepliedByNric() == null ? "" : enq.getRepliedByNric(),
                            DateUtils.formatDate(enq.getEnquiryDate()),
                            enq.getReplyDate() == null ? "" : DateUtils.formatDate(enq.getReplyDate())
                    });
                });
        CsvRW.writeCsv(ENQUIRY_FILE, dataList);
        System.out.println("Saved enquiries.");
        this.enquiries = new ArrayList<>(enquiriesToSave);
    }

    /**
     * Adds a new enquiry to the internal list if an enquiry with the same ID
     * doesn't already exist.
     * Prints an error message if a duplicate ID is detected.
     *
     * @param enquiry The Enquiry object to add.
     */
    @Override
    public void addEnquiry(Enquiry enquiry) {
        if (enquiry != null && findEnquiryById(enquiry.getEnquiryId()) == null) {
            this.enquiries.add(enquiry);
        } else if (enquiry != null) {
            System.err.println("Enquiry with ID " + enquiry.getEnquiryId() + " already exists.");
        }
    }

    /**
     * Removes an enquiry from the internal list based on its ID.
     *
     * @param enquiryId The ID of the enquiry to remove. If null, the method does
     *                  nothing.
     * @return true if an enquiry with the matching ID was found and removed, false
     *         otherwise.
     */
    @Override
    public boolean removeEnquiry(String enquiryId) {
        if (enquiryId != null) {
            return this.enquiries.removeIf(e -> enquiryId.equals(e.getEnquiryId()));
        }
        return false;
    }

    /**
     * Finds an enquiry by its unique ID from the internally managed list.
     *
     * @param enquiryId The ID of the enquiry to find.
     * @return The Enquiry object if found, or null if the ID is null or not found.
     */
    @Override
    public Enquiry findEnquiryById(String enquiryId) {
        if (enquiryId == null)
            return null;
        return this.enquiries.stream()
                .filter(e -> enquiryId.equals(e.getEnquiryId()))
                .findFirst()
                .orElse(null);
    }

    /**
     * Retrieves a list of all enquiries submitted by a specific applicant.
     * Filters the internal enquiry list based on the applicantNric field.
     *
     * @param applicantNric The NRIC of the applicant.
     * @return A list of Enquiry objects submitted by the specified applicant.
     *         Returns an empty list if NRIC is null or no enquiries are found.
     */
    @Override
    public List<Enquiry> getEnquiriesByApplicant(String applicantNric) {
        if (applicantNric == null)
            return new ArrayList<>();
        return this.enquiries.stream()
                .filter(e -> applicantNric.equals(e.getApplicantNric()))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a list of all enquiries associated with a specific project.
     * Filters the internal enquiry list based on the projectName field.
     *
     * @param projectName The name of the project.
     * @return A list of Enquiry objects for the specified project. Returns an empty
     *         list if projectName is null or no enquiries are found.
     */
    @Override
    public List<Enquiry> getEnquiriesByProject(String projectName) {
        if (projectName == null)
            return new ArrayList<>();
        return this.enquiries.stream()
                .filter(e -> projectName.equals(e.getProjectName()))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a copy of the list containing all enquiries currently managed by
     * the service.
     * Returning a copy prevents external modification of the internal state.
     *
     * @return A new ArrayList containing all Enquiry objects.
     */
    @Override
    public List<Enquiry> getAllEnquiries() {
        return new ArrayList<>(this.enquiries);
    }
}
```

Controllers\OfficerActionController.java (209)
```java
/**
 * Controller handling specific actions initiated by an HDB Officer related to their role,
 * such as registering to handle projects and viewing their registration status or handling project details.
 * Inherits common functionality from BaseController.
 *
 * @author Kishore Kumar
 */
package Controllers;

import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.Collections;

import Enums.OfficerRegistrationStatus;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class OfficerActionController extends BaseController {
    /**
     * Constructs a new OfficerActionController.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param currentUser                The currently logged-in User (expected to
     *                                   be HDBOfficer).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public OfficerActionController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
    }

    /**
     * Allows an HDB Officer to register their interest in handling a specific BTO
     * project.
     * Performs several eligibility checks:
     * - Officer cannot have an active/booked/pending withdrawal BTO application.
     * - Finds projects available for registration based on:
     * - Project has remaining officer slots.
     * - Project application period is not expired.
     * - Officer does not already have any registration (Pending/Approved/Rejected)
     * for the project.
     * - Project dates do not overlap with any project the officer is currently
     * handling (Approved).
     * - Project dates do not overlap with any project the officer has a PENDING
     * registration for.
     * - Officer has never submitted a BTO application (any status) for this
     * project.
     * - Displays the list of available projects.
     * - Prompts the officer to select a project.
     * - Creates a new OfficerRegistration record with PENDING status.
     * - Saves the new registration.
     */
    public void registerForProject() {
        if (!(currentUser instanceof HDBOfficer)) {
            System.out.println("Error: Only HDB Officers can register to handle projects.");
            return;
        }
        HDBOfficer officer = (HDBOfficer) currentUser;
        Date currentDate = DateUtils.getCurrentDate();

        if (officer.hasActiveApplication() || officer.hasBooked()) {
            System.out.println(
                    "Error: Cannot register to handle a project while you have an active or booked BTO application ("
                            + officer.getAppliedProjectName() + ", Status: " + officer.getApplicationStatus() + ").");
            return;
        }
        if (officer.hasPendingWithdrawal()) {
            System.out.println(
                    "Error: Cannot register to handle a project while you have a pending withdrawal request for application '"
                            + officer.getAppliedProjectName() + "'.");
            return;
        }

        System.out.println("\n--- Register to Handle Project ---");

        Project currentlyHandlingProject = getOfficerHandlingProject(officer);

        List<Project> pendingRegistrationProjects = officerRegistrationService
                .getRegistrationsByOfficer(officer.getNric())
                .stream()
                .filter(reg -> reg.getStatus() == OfficerRegistrationStatus.PENDING)
                .map(reg -> projectService.findProjectByName(reg.getProjectName()))
                .filter(p -> p != null)
                .collect(Collectors.toList());

        List<Project> availableProjects = projectService.getAllProjects().stream()
                .filter(p -> p.getRemainingOfficerSlots() > 0)
                .filter(p -> !p.isApplicationPeriodExpired(currentDate))
                .filter(p -> officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                        .stream()
                        .noneMatch(reg -> reg.getProjectName().equals(p.getProjectName())))
                .filter(p -> currentlyHandlingProject == null || !checkDateOverlap(p, currentlyHandlingProject))
                .filter(p -> pendingRegistrationProjects.stream()
                        .noneMatch(pendingProject -> checkDateOverlap(p, pendingProject)))
                .filter(p -> applicationService.getApplicationsByApplicant(officer.getNric())
                        .stream()
                        .noneMatch(app -> app.getProjectName().equals(p.getProjectName())))
                .sorted(Comparator.comparing((Project p) -> p.getProjectName()))
                .collect(Collectors.toList());

        if (availableProjects.isEmpty()) {
            System.out
                    .println("No projects currently available for you to register for based on eligibility criteria:");
            System.out.println("- Project must have open officer slots and not be expired.");
            System.out.println(
                    "- You must not already have any registration (Pending/Approved/Rejected) for the project.");
            System.out.println("- You cannot have an active/booked BTO application or a pending withdrawal request.");
            System.out.println("- Project dates cannot overlap with a project you are already handling.");
            System.out.println("- Project dates cannot overlap with a project you have a PENDING registration for.");
            System.out.println("- You cannot register for a project you have previously applied for (any status).");
            return;
        }

        viewAndSelectProject(availableProjects, "Select Project to Register For");
        Project selectedProject = selectProjectFromList(availableProjects);

        if (selectedProject != null) {
            OfficerRegistration newRegistration = new OfficerRegistration(officer.getNric(),
                    selectedProject.getProjectName(), currentDate);
            officerRegistrationService.addRegistration(newRegistration);
            System.out.println("Registration request submitted for project '" + selectedProject.getProjectName()
                    + "'. Status: PENDING approval by Manager.");
            officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
        }
    }

    /**
     * Displays the HDB Officer's current project handling status and registration
     * history.
     * - Shows the project currently being handled (if any, with APPROVED status and
     * active period).
     * - Lists all other registration requests (Pending, Rejected, or past Approved)
     * sorted by date.
     */
    public void viewRegistrationStatus() {
        if (!(currentUser instanceof HDBOfficer))
            return;
        HDBOfficer officer = (HDBOfficer) currentUser;
        System.out.println("\n--- Your HDB Officer Registration Status ---");

        Project handlingProject = getOfficerHandlingProject(officer);
        if (handlingProject != null) {
            System.out.println("You are currently APPROVED and HANDLING project: " + handlingProject.getProjectName());
            System.out.println(
                    "  (Application Period: " + DateUtils.formatDate(handlingProject.getApplicationOpeningDate())
                            + " to " + DateUtils.formatDate(handlingProject.getApplicationClosingDate()) + ")");
            System.out.println("----------------------------------------");
        }

        List<OfficerRegistration> myOtherRegistrations = officerRegistrationService
                .getRegistrationsByOfficer(officer.getNric())
                .stream()
                .filter(reg -> handlingProject == null
                        || !reg.getProjectName().equals(handlingProject.getProjectName()))
                .sorted(Comparator.comparing((OfficerRegistration oR) -> oR.getRegistrationDate()).reversed())
                .collect(Collectors.toList());

        if (myOtherRegistrations.isEmpty() && handlingProject == null) {
            System.out.println("You have no past or pending registration requests.");
        } else if (!myOtherRegistrations.isEmpty()) {
            System.out.println("Other Registration History/Requests:");
            for (OfficerRegistration reg : myOtherRegistrations) {
                System.out.printf("- Project: %-15s | Status: %-10s | Date: %s\n",
                        reg.getProjectName(), reg.getStatus(), DateUtils.formatDate(reg.getRegistrationDate()));
            }
        } else {
        }
    }

    /**
     * Displays the detailed information for the project the HDB Officer is
     * currently handling.
     * Uses the shared `viewAndSelectProject` display format from BaseController.
     * If the officer is not handling any active project, it informs them.
     */
    public void viewHandlingProjectDetails() {
        if (!(currentUser instanceof HDBOfficer))
            return;
        HDBOfficer officer = (HDBOfficer) currentUser;

        Project project = getOfficerHandlingProject(officer);

        if (project == null) {
            System.out.println(
                    "You are not currently handling any active project. Register for one first or check registration status.");
            return;
        }

        System.out.println("\n--- Details for Handling Project: " + project.getProjectName() + " ---");
        viewAndSelectProject(Collections.singletonList(project), "Project Details");
    }
}
```

Controllers\EnquiryManagerController.java (206)
```java
/**
 * Controller handling actions performed by an HDB Manager related to viewing and managing enquiries.
 * Allows viewing all enquiries system-wide or viewing/replying to enquiries for managed projects.
 * Requires an IEnquiryService. Inherits common functionality from BaseController.
 *
 * @author Kai Wang
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Models.Enquiry;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class EnquiryManagerController extends BaseController {

    private final IEnquiryService enquiryService;

    /**
     * Constructs a new EnquiryManagerController.
     * Ensures the current user is an HDBManager.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access.
     * @param currentUser                The currently logged-in User (must be
     *                                   HDBManager).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     * @throws IllegalArgumentException if the currentUser is not an HDBManager.
     */
    public EnquiryManagerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        this.enquiryService = enquiryService;
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("EnquiryManagerController requires an HDBManager user.");
        }
    }

    /**
     * Displays all enquiries present in the system, regardless of project or
     * manager assignment.
     * Retrieves all enquiries from the enquiry service.
     * Sorts them by project name, then by enquiry date (newest first).
     * Prints details for each enquiry using a helper method.
     */
    public void viewAllEnquiries() {
        System.out.println("\n--- View Enquiries (ALL Projects) ---");
        List<Enquiry> allEnquiries = enquiryService.getAllEnquiries();

        if (allEnquiries.isEmpty()) {
            System.out.println("No enquiries found in the system.");
            return;
        }

        allEnquiries.stream()
                .sorted(Comparator.comparing((Enquiry e) -> e.getProjectName())
                        .thenComparing((Enquiry e) -> e.getEnquiryDate(), Comparator.reverseOrder()))
                .forEach(e -> {
                    printEnquiryDetails(e);
                    System.out.println("----------------------------------------");
                });
    }

    /**
     * Allows the HDB Manager to view and reply to enquiries specifically for the
     * projects they manage.
     * Optionally applies the manager's current view filters (location, flat type)
     * to the list of managed projects considered.
     * - Retrieves enquiries related to the filtered list of managed projects.
     * - Separates enquiries into unreplied and replied lists.
     * - Displays unreplied enquiries and prompts the manager to select one to reply
     * to.
     * - If an enquiry is selected, prompts for the reply text.
     * - Sets the reply details on the Enquiry object using its `setReply` method.
     * - Saves the updated enquiry list via the enquiry service.
     * - Displays the list of already replied enquiries for the managed projects.
     */
    public void viewAndReplyToManagedEnquiries() {
        System.out.println("\n--- View/Reply Enquiries (Managed Projects) ---");
        List<String> myManagedProjectNames = projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                .map((Project p) -> p.getProjectName())
                .collect(Collectors.toList());

        if (myManagedProjectNames.isEmpty()) {
            String filterMsg = (filterLocation != null || filterFlatType != null) ? " matching the current filters."
                    : ".";
            System.out.println("You are not managing any projects" + filterMsg + " For which to view enquiries.");
            return;
        }

        List<Enquiry> managedEnquiries = enquiryService.getAllEnquiries().stream()
                .filter(e -> myManagedProjectNames.contains(e.getProjectName()))
                .sorted(Comparator.comparing((Enquiry e) -> e.getProjectName())
                        .thenComparing((Enquiry e) -> e.getEnquiryDate(), Comparator.reverseOrder()))
                .collect(Collectors.toList());

        if (managedEnquiries.isEmpty()) {
            String filterMsg = (filterLocation != null || filterFlatType != null) ? " (matching filters)." : ".";
            System.out.println("No enquiries found for the projects you manage" + filterMsg);
            return;
        }

        List<Enquiry> unrepliedEnquiries = managedEnquiries.stream()
                .filter(e -> !e.isReplied())
                .collect(Collectors.toList());
        List<Enquiry> repliedEnquiries = managedEnquiries.stream()
                .filter((Enquiry e) -> e.isReplied())
                .collect(Collectors.toList());

        System.out.println("--- Unreplied Enquiries (Managed Projects"
                + ((filterLocation != null || filterFlatType != null) ? " - Filtered" : "") + ") ---");
        if (unrepliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < unrepliedEnquiries.size(); i++) {
                Enquiry e = unrepliedEnquiries.get(i);
                System.out.printf("%d. ", i + 1);
                printEnquiryDetails(e);
                System.out.println("---");
            }
            int choice = getIntInput("Enter the number of the enquiry to reply to (or 0 to skip): ", 0,
                    unrepliedEnquiries.size());

            if (choice >= 1) {
                Enquiry enquiryToReply = unrepliedEnquiries.get(choice - 1);
                System.out.print("Enter your reply: ");
                String replyText = scanner.nextLine().trim();
                if (enquiryToReply.setReply(replyText, currentUser.getNric(), DateUtils.getCurrentDate())) {
                    System.out.println("Reply submitted successfully.");
                    enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
                } else {
                    System.out.println("Reply not submitted.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
        }

        System.out.println("\n--- Replied Enquiries (Managed Projects"
                + ((filterLocation != null || filterFlatType != null) ? " - Filtered" : "") + ") ---");
        if (repliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Enquiry e : repliedEnquiries) {
                printEnquiryDetails(e);
                System.out.println("----------------------------------------");
            }
        }
    }

    /**
     * Prints the details of a given enquiry.
     * Includes the enquiry ID, project name, applicant NRIC, applicant name,
     * enquiry date, and the enquiry text.
     * If the enquiry has been replied to, it also includes the reply details:
     * replier NRIC, replier role, reply date, and reply text.
     * 
     * @param e The Enquiry object to print details for.
     */

    private void printEnquiryDetails(Enquiry e) {
        User applicant = userService.findUserByNric(e.getApplicantNric());
        String applicantName = applicant != null ? applicant.getName() : "N/A";
        System.out.printf("ID: %s | Project: %-15s | Applicant: %s (%s) | Date: %s\n",
                e.getEnquiryId(),
                e.getProjectName(),
                e.getApplicantNric(),
                applicantName,
                DateUtils.formatDate(e.getEnquiryDate()));
        System.out.println("   Enquiry: " + e.getEnquiryText());
        if (e.isReplied()) {
            User replier = userService.findUserByNric(e.getRepliedByNric());
            String replierRole = replier != null ? " (" + replier.getRole().toString().replace("HDB_", "") + ")" : "";

            System.out.printf("   Reply (by %s%s on %s): %s\n",
                    e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                    replierRole,
                    e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                    e.getReplyText());
        } else {
            System.out.println("   Reply: (Pending)");
        }
    }
}
```

BTOApp.java (196)
```java

/**
 * Main application class for the BTO Management System.
 * Initializes services, loads data, handles the main login loop,
 * instantiates appropriate controllers and views based on user role,
 * and manages application shutdown.
 *
 * @author Patrick
 */

import java.util.Scanner;

import Models.User;

import Controllers.*;
import Services.*;

import Views.ApplicantView;
import Views.BaseView;
import Views.OfficerView;
import Views.ManagerView;

public class BTOApp {

    private IUserService userService;
    private IProjectService projectService;
    private IApplicationService applicationService;
    private IEnquiryService enquiryService;
    private IOfficerRegistrationService officerRegistrationService;

    private AuthController authController;
    private Scanner scanner;

    /**
     * Constructs the BTOApp instance.
     * Initializes the Scanner and instantiates all the necessary service
     * implementations
     * (UserService, ProjectService, ApplicationService, EnquiryService,
     * OfficerRegistrationService).
     */
    public BTOApp() {
        scanner = new Scanner(System.in);
        userService = new UserService();
        projectService = new ProjectService();
        applicationService = new ApplicationService();
        enquiryService = new EnquiryService();
        officerRegistrationService = new OfficerRegistrationService();
    }

    /**
     * Initializes the application by loading data from persistent storage (CSV
     * files)
     */
    public void initialize() {
        System.out.println("Initializing BTO Management System...");

        System.out.println("Loading users...");
        userService.loadUsers();

        System.out.println("Loading projects...");
        projectService.loadProjects(userService.getAllUsers());

        System.out.println("Loading applications...");
        applicationService.loadApplications(projectService.getAllProjects());

        System.out.println("Loading officer registrations...");
        officerRegistrationService.loadOfficerRegistrations(userService.getAllUsers(), projectService.getAllProjects());

        System.out.println("Loading enquiries...");
        enquiryService.loadEnquiries();

        System.out.println("Performing data synchronization...");
        DataService.synchronizeData(userService, projectService, applicationService, officerRegistrationService);

        authController = new AuthController(userService);

        System.out.println("Initialization complete. System ready.");
    }

    /**
     * Runs the main application loop.
     * Continuously prompts the user to log in via {@link #loginScreen()}.
     * If login is successful, it calls {@link #showRoleMenu(User)} to display the
     * appropriate menu.
     * After logout, it returns to the login screen or exits if the user chooses not
     * to retry after a failed login.
     * Includes a call to DataService.synchronizeData before each login attempt
     * (consider if this frequency is necessary).
     */
    public void run() {
        User currentUser = null;
        while (true) {
            DataService.synchronizeData(userService, projectService, applicationService, officerRegistrationService);

            currentUser = loginScreen();

            if (currentUser != null) {
                showRoleMenu(currentUser);
                currentUser = null;
                System.out.println("\nReturning to Login Screen...");
            } else {
                System.out.print("Login failed. Try again? (yes/no): ");
                String retry = scanner.nextLine().trim().toLowerCase();
                if (!retry.equals("yes")) {
                    break;
                }
            }
        }
    }

    /**
     * Handles the user interface for logging in.
     * Prompts the user for NRIC and password.
     * Calls the {@link Controllers.AuthController#login(String, String)} method to
     * authenticate the user.
     * Prints success or failure messages.
     *
     * @return The authenticated User object if login is successful, null otherwise.
     */
    private User loginScreen() {
        System.out.println("\n--- BTO Management System Login ---");
        System.out.print("Enter NRIC: ");
        String nric = scanner.nextLine().trim().toUpperCase();
        System.out.print("Enter Password: ");
        String password = scanner.nextLine();

        User user = authController.login(nric, password);
        if (user != null) {
            System.out.println("Login successful! Welcome, " + user.getName() + " (" + user.getRole() + ")");
        }
        return user;
    }

    /**
     * Instantiates the appropriate main controller and view based on the logged-in
     * user's role.
     * Calls the `displayMenu()` method of the created view to show the
     * role-specific options.
     *
     * @param user The currently logged-in User object.
     */
    private void showRoleMenu(User user) {
        BaseView view;

        switch (user.getRole()) {
            case APPLICANT:
                ApplicantController appController = new ApplicantController(
                        userService, projectService, applicationService, officerRegistrationService, enquiryService,
                        user, scanner, authController);
                view = new ApplicantView(scanner, user, appController, authController);
                break;
            case HDB_OFFICER:
                OfficerController offController = new OfficerController(
                        userService, projectService, applicationService, officerRegistrationService, enquiryService,
                        user, scanner, authController);
                view = new OfficerView(scanner, user, offController, authController);
                break;
            case HDB_MANAGER:
                ManagerController manController = new ManagerController(
                        userService, projectService, applicationService, officerRegistrationService, enquiryService,
                        user, scanner, authController);
                view = new ManagerView(scanner, user, manController, authController);
                break;
            default:
                System.err.println("FATAL Error: Unknown user role encountered: " + user.getRole());
                return;
        }
        view.displayMenu();
    }

    /**
     * The main entry point of the BTO Management System application.
     * Creates an instance of BTOApp, initializes it (loads data), and runs the main
     * loop.
     * Includes basic error handling for unexpected exceptions during execution.
     * Ensures the scanner is closed upon termination.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BTOApp app = new BTOApp();
        try {
            app.initialize();
            app.run();
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (app.scanner != null) {
                app.scanner.close();
            }
        }
        System.out.println("Application terminated.");
        System.exit(1);
    }
}
```

Services\UserService.java (196)
```java

/**
 * Service implementation for managing User data (Applicants, Officers, Managers).
 * Handles loading user data from separate CSV files for each role and saving them back.
 * Provides methods for finding users by NRIC and retrieving all users.
 *
 * @author Jordon
 */
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import Enums.MaritalStatus;
import Models.Applicant;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.User;

public class UserService implements IUserService {
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";
    private static final String DELIMITER = ",";
    private static final String[] APPLICANT_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] OFFICER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] MANAGER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };

    private Map<String, User> users;

    /**
     * Constructs a new UserService. Initializes the internal user map.
     */
    public UserService() {
        this.users = new HashMap<>();
    }

    /**
     * Loads user data from ApplicantList.csv, OfficerList.csv, and ManagerList.csv.
     * Validates NRIC format and handles potential duplicates or role conflicts
     * (e.g., user in multiple files).
     * Populates the internal user map.
     *
     * @return The map containing all loaded users, keyed by NRIC.
     */
    @Override
    public Map<String, User> loadUsers() {
        this.users.clear();

        CsvRW.readCsv(APPLICANT_LIST_FILE, APPLICANT_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim();
                if (!Utils.NricValidator.isValidNric(nric) || this.users.containsKey(nric)) {
                    if (this.users.containsKey(nric))
                        System.err.println("Duplicate NRIC found in ApplicantList: " + nric + ". Skipping duplicate.");
                    else
                        System.err.println("Invalid NRIC format in ApplicantList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                Applicant applicant = new Applicant(nric, data[4].trim(), data[0].trim(), age, status);
                this.users.put(nric, applicant);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing applicant data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        CsvRW.readCsv(OFFICER_LIST_FILE, OFFICER_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim();
                if (!Utils.NricValidator.isValidNric(nric)) {
                    System.err.println("Invalid NRIC format in OfficerList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                HDBOfficer officer = new HDBOfficer(nric, data[4].trim(), data[0].trim(), age, status);
                if (this.users.containsKey(nric) && !(this.users.get(nric) instanceof HDBOfficer)) {
                    System.out.println(
                            "Info: User " + nric + " found in both Applicant and Officer lists. Using Officer role.");
                } else if (this.users.containsKey(nric)) {
                    System.err.println("Duplicate NRIC found in OfficerList: " + nric + ". Skipping duplicate.");
                    return;
                }
                this.users.put(nric, officer);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing officer data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        CsvRW.readCsv(MANAGER_LIST_FILE, MANAGER_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim();
                if (!Utils.NricValidator.isValidNric(nric)) {
                    System.err.println("Invalid NRIC format in ManagerList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                HDBManager manager = new HDBManager(nric, data[4].trim(), data[0].trim(), age, status);
                if (this.users.containsKey(nric) && !(this.users.get(nric) instanceof HDBManager)) {
                    System.out.println("Info: User " + nric + " found in other lists. Using Manager role.");
                } else if (this.users.containsKey(nric)) {
                    System.err.println("Duplicate NRIC found in ManagerList: " + nric + ". Skipping duplicate.");
                    return;
                }
                this.users.put(nric, manager);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing manager data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        System.out.println("Loaded " + this.users.size() + " unique users.");
        return this.users;
    }

    /**
     * Saves the provided map of users back to their respective CSV files
     * (ApplicantList, OfficerList, ManagerList).
     * Overwrites the existing files. Updates the internal user map to match the
     * saved state.
     *
     * @param usersToSave The map of users (NRIC to User object) to save.
     */
    @Override
    public void saveUsers(Map<String, User> usersToSave) {
        List<String[]> applicantData = new ArrayList<>();
        List<String[]> officerData = new ArrayList<>();
        List<String[]> managerData = new ArrayList<>();

        applicantData.add(APPLICANT_HEADER);
        officerData.add(OFFICER_HEADER);
        managerData.add(MANAGER_HEADER);

        usersToSave.values().forEach(user -> {
            String[] userData = {
                    user.getName(),
                    user.getNric(),
                    String.valueOf(user.getAge()),
                    user.getMaritalStatus().name(),
                    user.getPassword()
            };
            switch (user.getRole()) {
                case HDB_MANAGER:
                    managerData.add(userData);
                    break;
                case HDB_OFFICER:
                    officerData.add(userData);
                    break;
                case APPLICANT:
                    applicantData.add(userData);
                    break;
            }
        });

        CsvRW.writeCsv(APPLICANT_LIST_FILE, applicantData);
        CsvRW.writeCsv(OFFICER_LIST_FILE, officerData);
        CsvRW.writeCsv(MANAGER_LIST_FILE, managerData);
        System.out.println("Saved users.");
        if (usersToSave == this.users) {
            this.users = new HashMap<>(usersToSave);
        } else {
        }
    }

    /**
     * Finds a user by their NRIC from the internally managed map.
     *
     * @param nric The NRIC of the user to find.
     * @return The User object if found, or null otherwise.
     */
    @Override
    public User findUserByNric(String nric) {
        return this.users.get(nric);
    }

    /**
     * Retrieves a copy of the map containing all users currently managed by the
     * service.
     * Returning a copy prevents external modification of the internal state.
     *
     * @return A new HashMap containing all users (NRIC to User object).
     */
    @Override
    public Map<String, User> getAllUsers() {
        return new HashMap<>(this.users);
    }
}
```

Services\CsvRW.java (191)
```java
/**
 * Static utility class for reading and writing data to/from CSV files.
 * Handles basic CSV parsing, including quoted fields containing delimiters,
 * and escaping fields during writing. Also manages file creation with headers if files don't exist.
 *
 * @author Jordon
 */
package Services;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class CsvRW {
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";
    private static final String PROJECT_FILE = DATA_DIR + File.separator + "ProjectList.csv";
    private static final String APPLICATION_FILE = DATA_DIR + File.separator + "applications.csv";
    private static final String ENQUIRY_FILE = DATA_DIR + File.separator + "enquiries.csv";
    private static final String OFFICER_REGISTRATION_FILE = DATA_DIR + File.separator + "officer_registrations.csv";

    private static final String DELIMITER = ",";
    private static final String LIST_DELIMITER = ";";
    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    private static final String[] APPLICANT_HEADER = {"Name", "NRIC", "Age", "Marital Status", "Password"};
    private static final String[] OFFICER_HEADER = {"Name", "NRIC", "Age", "Marital Status", "Password"};
    private static final String[] MANAGER_HEADER = {"Name", "NRIC", "Age", "Marital Status", "Password"};
    private static final String[] PROJECT_HEADER = {
        "Project Name", "Neighborhood", "Type 1", "Number of units for Type 1", "Selling price for Type 1",
        "Type 2", "Number of units for Type 2", "Selling price for Type 2",
        "Application opening date", "Application closing date", "Manager", "Officer Slot", "Officer", "Visibility"
    };
    private static final String[] APPLICATION_HEADER = {"ApplicationID", "ApplicantNRIC", "ProjectName", "FlatTypeApplied", "Status", "ApplicationDate"};
    private static final String[] ENQUIRY_HEADER = {"EnquiryID", "ApplicantNRIC", "ProjectName", "EnquiryText", "ReplyText", "RepliedByNRIC", "EnquiryDate", "ReplyDate"};
    private static final String[] OFFICER_REGISTRATION_HEADER = {"RegistrationID", "OfficerNRIC", "ProjectName", "Status", "RegistrationDate"};

/**
 * Reads data from a specified CSV file.
 * Skips the header row and empty lines.
 * Attempts to handle quoted fields containing the delimiter.
 * Validates the number of columns per row against the expected count.
 * If the file doesn't exist, it attempts to create it with the appropriate header.
 * Handles a specific edge case for older ProjectList.csv files missing the 'Visibility' column.
 *
 * @param filename The path to the CSV file.
 * @param expectedColumns The expected number of columns in each data row (excluding header).
 * @return A List of String arrays, where each array represents a row of data. Returns an empty list if the file doesn't exist or contains no valid data.
 */
    public static List<String[]> readCsv(String filename, int expectedColumns) {
        List<String[]> data = new ArrayList<>();
        Path path = Paths.get(filename);

        if (!Files.exists(path)) {
            System.err.println("Warning: File not found - " + filename + ". Attempting to create.");
            try {
                Path parent = path.getParent();
                if (parent != null) {
                    Files.createDirectories(parent);
                }
                Files.createFile(path);
                String[] header = getHeaderForFile(filename);
                if (header != null) {
                    writeCsv(filename, Collections.singletonList(header));
                    System.out.println("Created new file with header: " + filename);
                } else {
                     System.err.println("Could not determine header for new file: " + filename);
                }
            } catch (IOException e) {
                System.err.println("FATAL: Error creating file: " + filename + " - " + e.getMessage() + ". Application might not function correctly.");
            }
            return data;
        }

        try (BufferedReader br = Files.newBufferedReader(path)) {
            String line;
            boolean isFirstLine = true;
            int lineNumber = 0;
            while ((line = br.readLine()) != null) {
                lineNumber++;
                if (isFirstLine || line.trim().isEmpty()) {
                    isFirstLine = false;
                    continue;
                }

                String[] values = line.split(DELIMITER + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1);

                for (int i = 0; i < values.length; i++) {
                    values[i] = values[i].trim();
                    if (values[i].startsWith("\"") && values[i].endsWith("\"") && values[i].length() >= 2) {
                        values[i] = values[i].substring(1, values[i].length() - 1).replace("\"\"", "\"");
                    }
                }

                if (values.length < expectedColumns && filename.endsWith(PROJECT_FILE.substring(DATA_DIR.length() + 1)) && values.length == expectedColumns -1) {
                     String[] paddedValues = Arrays.copyOf(values, expectedColumns);
                     paddedValues[expectedColumns - 1] = "0";
                     values = paddedValues;
                     System.out.println("Info: Line " + lineNumber + " in " + filename + " seems to be missing the 'Visibility' column. Assuming '0' (Off).");
                } else if (values.length != expectedColumns) {
                     System.err.println("Warning: Malformed line " + lineNumber + " in " + filename + ". Expected " + expectedColumns + " columns, found " + values.length + ". Skipping line: " + line);
                     continue;
                }

                data.add(values);
            }
        } catch (IOException e) {
            System.err.println("FATAL: Error reading file: " + filename + " - " + e.getMessage());
        }
        return data;
    }

    /**
 * Writes data to a specified CSV file, overwriting existing content.
 * Ensures the parent directory exists.
 * Escapes fields containing delimiters, quotes, or newlines before writing.
 *
 * @param filename The path to the CSV file.
 * @param data A List of String arrays, where the first array is typically the header and subsequent arrays are data rows.
 */
    public static void writeCsv(String filename, List<String[]> data) {
        Path path = Paths.get(filename);
        try {
             Path parent = path.getParent();
             if (parent != null) {
                 Files.createDirectories(parent);
             }

             try (BufferedWriter bw = Files.newBufferedWriter(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {
                for (String[] row : data) {
                    String line = Arrays.stream(row)
                    .map(field -> CsvRW.escapeCsvField(field))
                                        .collect(Collectors.joining(DELIMITER));
                    bw.write(line);
                    bw.newLine();
                }
            }
        } catch (IOException e) {
            System.err.println("Error writing file: " + filename + " - " + e.getMessage());
        }
    }

    /**
     * * Returns the appropriate header for a given file based on its name.
     * @param filename The name of the file.
     * @return The header for the file, or null if the file name is not recognized.
     */
    private static String[] getHeaderForFile(String filename) {
        Path p = Paths.get(filename);
        String baseName = p.getFileName().toString();

        if (baseName.equals(Paths.get(APPLICANT_LIST_FILE).getFileName().toString())) return APPLICANT_HEADER;
        if (baseName.equals(Paths.get(OFFICER_LIST_FILE).getFileName().toString())) return OFFICER_HEADER;
        if (baseName.equals(Paths.get(MANAGER_LIST_FILE).getFileName().toString())) return MANAGER_HEADER;
        if (baseName.equals(Paths.get(PROJECT_FILE).getFileName().toString())) return PROJECT_HEADER;
        if (baseName.equals(Paths.get(APPLICATION_FILE).getFileName().toString())) return APPLICATION_HEADER;
        if (baseName.equals(Paths.get(ENQUIRY_FILE).getFileName().toString())) return ENQUIRY_HEADER;
        if (baseName.equals(Paths.get(OFFICER_REGISTRATION_FILE).getFileName().toString())) return OFFICER_REGISTRATION_HEADER;

        return null;
    }

    /**
     * Escapes a CSV field by enclosing it in quotes if it contains the delimiter,
     * quotes, or newlines. Also doubles any existing quotes within the field.
     *
     * @param field The field to escape.
     * @return The escaped field.
     */
    private static String escapeCsvField(String field) {
        if (field == null) return "";
        if (field.contains(DELIMITER) || field.contains("\"") || field.contains(LIST_DELIMITER) || field.contains("\n") || field.contains("\r")) {
            return "\"" + field.replace("\"", "\"\"") + "\"";
        }
        return field;
    }
}
```

Controllers\ManagerController.java (186)
```java
/**
 * Main controller for the HDB Manager role.
 * It doesn't implement actions directly but delegates them to specialized sub-controllers
 * responsible for specific areas of management (Projects, Officer Registrations, Applications,
 * Withdrawals, Reports, Enquiries).
 * Inherits common functionality and state (like filters) from {@link BaseController}.
 *
 * @author Jordon
 */
package Controllers;

import java.util.Scanner;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

public class ManagerController extends BaseController {

    private final ProjectManagerController projectManagerController;
    private final OfficerRegistrationManagerController officerRegManagerController;
    private final ApplicationManagerController applicationManagerController;
    private final WithdrawalManagerController withdrawalManagerController;
    private final ReportManagerController reportManagerController;
    private final EnquiryManagerController enquiryManagerController;

    /**
     * Constructs a new ManagerController.
     * Instantiates and holds references to all the specialized manager
     * sub-controllers,
     * passing necessary dependencies (services, user, scanner, auth controller) to
     * them.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access (needed by
     *                                   multiple sub-controllers).
     * @param currentUser                The currently logged-in User (expected to
     *                                   be HDBManager).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public ManagerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);

        this.projectManagerController = new ProjectManagerController(userService, projectService, applicationService,
                officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.officerRegManagerController = new OfficerRegistrationManagerController(userService, projectService,
                applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.applicationManagerController = new ApplicationManagerController(userService, projectService,
                applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.withdrawalManagerController = new WithdrawalManagerController(userService, projectService,
                applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.reportManagerController = new ReportManagerController(userService, projectService, applicationService,
                officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.enquiryManagerController = new EnquiryManagerController(userService, projectService, applicationService,
                officerRegistrationService, enquiryService, currentUser, scanner, authController);

    }

    /**
     * Delegates the action to create a project to the ProjectManagerController.
     * 
     * @see ProjectManagerController#createProject()
     */
    public void createProject() {
        projectManagerController.createProject();
    }

    /**
     * Delegates the action to edit a project to the ProjectManagerController.
     * 
     * @see ProjectManagerController#editProject()
     */
    public void editProject() {
        projectManagerController.editProject();
    }

    /**
     * Delegates the action to delete a project to the ProjectManagerController.
     * 
     * @see ProjectManagerController#deleteProject()
     */
    public void deleteProject() {
        projectManagerController.deleteProject();
    }

    /**
     * Delegates the action to toggle project visibility to the
     * ProjectManagerController.
     * 
     * @see ProjectManagerController#toggleProjectVisibility()
     */
    public void toggleProjectVisibility() {
        projectManagerController.toggleProjectVisibility();
    }

    /**
     * Delegates the action to view all projects (manager oversight) to the
     * ProjectManagerController.
     * 
     * @see ProjectManagerController#viewAllProjects()
     */
    public void viewAllProjects() {
        projectManagerController.viewAllProjects();
    }

    /**
     * Delegates the action to view managed projects to the
     * ProjectManagerController.
     * 
     * @see ProjectManagerController#viewMyProjects()
     */
    public void viewMyProjects() {
        projectManagerController.viewMyProjects();
    }

    /**
     * Delegates the action to manage officer registrations to the
     * OfficerRegistrationManagerController.
     * 
     * @see OfficerRegistrationManagerController#manageOfficerRegistrations()
     */
    public void manageOfficerRegistrations() {
        officerRegManagerController.manageOfficerRegistrations();
    }

    /**
     * Delegates the action to manage BTO applications to the
     * ApplicationManagerController.
     * 
     * @see ApplicationManagerController#manageApplications()
     */
    public void manageApplications() {
        applicationManagerController.manageApplications();
    }

    /**
     * Delegates the action to manage withdrawal requests to the
     * WithdrawalManagerController.
     * 
     * @see WithdrawalManagerController#manageWithdrawalRequests()
     */
    public void manageWithdrawalRequests() {
        withdrawalManagerController.manageWithdrawalRequests();
    }

    /**
     * Delegates the action to generate the applicant report to the
     * ReportManagerController.
     * 
     * @see ReportManagerController#generateApplicantReport()
     */
    public void generateApplicantReport() {
        reportManagerController.generateApplicantReport();
    }

    /**
     * Delegates the action to view all enquiries to the EnquiryManagerController.
     * 
     * @see EnquiryManagerController#viewAllEnquiries()
     */
    public void viewAllEnquiries() {
        enquiryManagerController.viewAllEnquiries();
    }

    /**
     * Delegates the action to view and reply to managed enquiries to the
     * EnquiryManagerController.
     * 
     * @see EnquiryManagerController#viewAndReplyToManagedEnquiries()
     */
    public void viewAndReplyToManagedEnquiries() {
        enquiryManagerController.viewAndReplyToManagedEnquiries();
    }

}
```

Models\BTOApplication.java (171)
```java
/**
 * Represents a single BTO (Build-To-Order) application submitted by an applicant for a specific project.
 *
 * @author Jun Yang
 */
package Models;

import Enums.ApplicationStatus;
import Enums.FlatType;

import java.util.Date;

public class BTOApplication {
    private final String applicationId;
    private final String applicantNric;
    private final String projectName;
    private FlatType flatTypeApplied;
    private ApplicationStatus status;
    private final Date applicationDate;
    private ApplicationStatus statusBeforeWithdrawal;

    /**
     * Constructs a new BTOApplication when an applicant first applies.
     * The application ID is automatically generated based on NRIC and project name.
     * Initial status is set to PENDING.
     *
     * @param applicantNric   The NRIC of the applicant. Cannot be null.
     * @param projectName     The name of the project being applied for. Cannot be
     *                        null.
     * @param flatTypeApplied The type of flat applied for. Cannot be null.
     * @param applicationDate The date the application was submitted. Cannot be
     *                        null.
     * @throws IllegalArgumentException if any parameter is null.
     */
    public BTOApplication(String applicantNric, String projectName, FlatType flatTypeApplied, Date applicationDate) {
        if (applicantNric == null || projectName == null || flatTypeApplied == null || applicationDate == null) {
            throw new IllegalArgumentException("BTOApplication fields cannot be null");
        }
        this.applicationId = applicantNric + "_" + projectName;
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.flatTypeApplied = flatTypeApplied;
        this.status = ApplicationStatus.PENDING;
        this.applicationDate = applicationDate;
        this.statusBeforeWithdrawal = null;
    }

    /**
     * Constructs a BTOApplication object when loading data from storage.
     * Allows setting all fields, including the application ID and status.
     * Includes warnings for potentially inconsistent data (e.g., BOOKED status with
     * null flat type).
     *
     * @param applicationId   The unique ID of the application. Cannot be null.
     * @param applicantNric   The NRIC of the applicant. Cannot be null.
     * @param projectName     The name of the project. Cannot be null.
     * @param flatTypeApplied The type of flat applied for. Can be null but issues
     *                        warning if status implies it shouldn't be.
     * @param status          The status of the application. Cannot be null.
     * @param applicationDate The date the application was submitted. Cannot be
     *                        null.
     * @throws IllegalArgumentException if required fields are null.
     */
    public BTOApplication(String applicationId, String applicantNric, String projectName, FlatType flatTypeApplied,
            ApplicationStatus status, Date applicationDate) {
        if (applicationId == null || applicantNric == null || projectName == null || status == null
                || applicationDate == null) {
            throw new IllegalArgumentException("Required BTOApplication fields cannot be null when loading");
        }
        if (flatTypeApplied == null && (status == ApplicationStatus.BOOKED || status == ApplicationStatus.SUCCESSFUL
                || status == ApplicationStatus.PENDING_WITHDRAWAL)) {
            System.err.println(
                    "Warning: Loading " + status + " application (" + applicationId + ") with null flatTypeApplied.");
        }

        this.applicationId = applicationId;
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.flatTypeApplied = flatTypeApplied;
        this.status = status;
        this.applicationDate = applicationDate;
        this.statusBeforeWithdrawal = null;
        if (status == ApplicationStatus.PENDING_WITHDRAWAL) {
            System.err.println("Warning: Application " + applicationId
                    + " loaded with PENDING_WITHDRAWAL status. Original status before withdrawal is unknown. Reverting will assume PENDING/SUCCESSFUL based on flat type.");
        }
    }

    /**
     * Get the application ID.
     * 
     * @return The application ID string.
     */
    public String getApplicationId() {
        return applicationId;
    }

    /**
     * Get the NRIC of the applicant.
     * 
     * @return The applicant's NRIC string.
     */
    public String getApplicantNric() {
        return applicantNric;
    }

    /**
     * Get the name of the project applied for.
     * 
     * @return The project name string.
     */
    public String getProjectName() {
        return projectName;
    }

    /**
     * Get the type of flat applied for.
     * 
     * @return The flat type enum.
     */
    public FlatType getFlatTypeApplied() {
        return flatTypeApplied;
    }

    /**
     * Get the current status of the application.
     * 
     * @return The application status enum.
     */

    public ApplicationStatus getStatus() {
        return status;
    }

    /**
     * Get the date the application was submitted.
     * 
     * @return The application date.
     */
    public Date getApplicationDate() {
        return applicationDate;
    }

    /**
     * Get the status of the application before withdrawal.
     * 
     * @return The status before withdrawal.
     */
    public ApplicationStatus getStatusBeforeWithdrawal() {
        return statusBeforeWithdrawal;
    }

    /**
     * Sets the status of the application.
     * 
     * @param status The new application status. Cannot be null.
     * @throws IllegalArgumentException if status is null.
     */
    public void setStatus(ApplicationStatus status) {
        if (status != null) {
            if (status == ApplicationStatus.PENDING_WITHDRAWAL && this.status != ApplicationStatus.PENDING_WITHDRAWAL) {
                this.statusBeforeWithdrawal = this.status;
            }
            if (this.status == ApplicationStatus.PENDING_WITHDRAWAL && status != ApplicationStatus.PENDING_WITHDRAWAL) {
                this.statusBeforeWithdrawal = null;
            }
            this.status = status;
        }
    }

}
```

Controllers\EnquiryOfficerController.java (143)
```java
/**
 * Controller handling enquiry-related actions performed by an HDB Officer, specifically
 * viewing and replying to enquiries submitted for the project they are currently handling.
 * Requires an IEnquiryService. Inherits common functionality from BaseController.
 *
 * @author Jun Yang
 */
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Models.Enquiry;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

public class EnquiryOfficerController extends BaseController {

    private final IEnquiryService enquiryService;

    /**
     * Constructs a new EnquiryOfficerController.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access.
     * @param currentUser                The currently logged-in User (expected to
     *                                   be HDBOfficer).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public EnquiryOfficerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);
        this.enquiryService = enquiryService;
    }

    /**
     * Allows the HDB Officer to view and reply to enquiries for the project they
     * are currently handling.
     * - Checks if the officer is handling an active project.
     * - Retrieves all enquiries for that specific project using the enquiry
     * service.
     * - Separates enquiries into unreplied and replied lists.
     * - Displays unreplied enquiries and prompts the officer to select one to reply
     * to.
     * - If an enquiry is selected, prompts for the reply text.
     * - Sets the reply details on the Enquiry object using its `setReply` method.
     * - Saves the updated enquiry list via the enquiry service.
     * - Displays the list of already replied enquiries for the project.
     */
    public void viewAndReplyToEnquiries() {
        if (!(currentUser instanceof HDBOfficer))
            return;
        HDBOfficer officer = (HDBOfficer) currentUser;

        Project handlingProject = getOfficerHandlingProject(officer);

        if (handlingProject == null) {
            System.out.println("You need to be handling an active project to view and reply to its enquiries.");
            return;
        }
        String handlingProjectName = handlingProject.getProjectName();

        System.out.println("\n--- Enquiries for Project: " + handlingProjectName + " ---");
        List<Enquiry> projectEnquiries = enquiryService.getEnquiriesByProject(handlingProjectName)
                .stream()
                .sorted(Comparator.comparing((Enquiry e) -> e.getEnquiryDate()).reversed())
                .collect(Collectors.toList());

        if (projectEnquiries.isEmpty()) {
            System.out.println("No enquiries found for this project.");
            return;
        }

        List<Enquiry> unrepliedEnquiries = projectEnquiries.stream()
                .filter(e -> !e.isReplied())
                .collect(Collectors.toList());
        List<Enquiry> repliedEnquiries = projectEnquiries.stream()
                .filter((Enquiry e) -> e.isReplied())
                .collect(Collectors.toList());

        System.out.println("--- Unreplied Enquiries ---");
        if (unrepliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < unrepliedEnquiries.size(); i++) {
                Enquiry e = unrepliedEnquiries.get(i);
                System.out.printf("%d. ID: %s | Applicant: %s | Date: %s\n",
                        i + 1, e.getEnquiryId(), e.getApplicantNric(), DateUtils.formatDate(e.getEnquiryDate()));
                System.out.println("   Enquiry: " + e.getEnquiryText());
                System.out.println("---");
            }
            int choice = getIntInput("Enter the number of the enquiry to reply to (or 0 to skip): ", 0,
                    unrepliedEnquiries.size());

            if (choice >= 1) {
                Enquiry enquiryToReply = unrepliedEnquiries.get(choice - 1);
                System.out.print("Enter your reply: ");
                String replyText = scanner.nextLine().trim();
                if (enquiryToReply.setReply(replyText, currentUser.getNric(), DateUtils.getCurrentDate())) {
                    System.out.println("Reply submitted successfully.");
                    enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
                } else {
                    System.out.println("Reply not submitted.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
        }

        System.out.println("\n--- Replied Enquiries ---");
        if (repliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Enquiry e : repliedEnquiries) {
                System.out.printf("ID: %s | Applicant: %s | Enquiry Date: %s\n",
                        e.getEnquiryId(), e.getApplicantNric(), DateUtils.formatDate(e.getEnquiryDate()));
                System.out.println("   Enquiry: " + e.getEnquiryText());
                System.out.printf("   Reply (by %s on %s): %s\n",
                        e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                        e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                        e.getReplyText());
                System.out.println("--------------------");
            }
        }
    }
}
```

Views\OfficerView.java (143)
```java
/**
 * View component responsible for displaying the menu and handling input for the HDB Officer role.
 * Interacts with the {@link Controllers.OfficerController} to execute actions.
 * Includes both officer-specific actions and inherited applicant actions.
 *
 * @author Jun Yang
 */
package Views;

import Controllers.OfficerController;
import Controllers.AuthController;
import Models.User;
import Models.Project;
import Models.HDBOfficer;

import java.util.Scanner;

public class OfficerView extends BaseView {
    private final OfficerController officerController;
    
    /**
     * Constructs a new OfficerView.
     *
     * @param scanner        Scanner instance for reading user input.
     * @param currentUser    The currently logged-in User (expected to be
     *                       HDBOfficer).
     * @param controller     The OfficerController associated with this view.
     * @param authController Controller for authentication tasks.
     */
    public OfficerView(Scanner scanner, User currentUser, OfficerController controller, AuthController authController) {
        super(scanner, currentUser, controller, authController);
        this.officerController = controller;
    }

    /**
     * Displays the main menu for the HDB Officer role.
     * Shows the currently handled project (if any).
     * Presents options for officer actions (registration, viewing status/details,
     * managing enquiries/bookings),
     * inherited applicant actions (viewing/applying for projects, managing own
     * applications/enquiries),
     * common actions (filters, password change), and logging out.
     * Reads user input and calls the corresponding methods on the OfficerController
     * or BaseView helpers.
     * Loops until the user chooses to logout.
     */
    @Override
    public void displayMenu() {
        boolean logout = false;
        while (!logout) {
            System.out.println("\n=========== HDB Officer Menu ===========");
            System.out.println("Welcome, Officer " + currentUser.getName() + "!");
            Project handlingProject = officerController.getOfficerHandlingProject((HDBOfficer) currentUser);
            if (handlingProject != null) {
                System.out.println("--> Currently Handling Project: " + handlingProject.getProjectName() + " <--");
            } else {
                System.out.println("--> Not currently handling any project <--");
            }
            System.out.println("--- Officer Actions ---");
            System.out.println(" 1. Register to Handle Project");
            System.out.println(" 2. View My Registration Status");
            System.out.println(" 3. View Handling Project Details");
            System.out.println(" 4. View/Reply Enquiries (Handling Project)");
            System.out.println(" 5. Manage Flat Booking (Process Successful Applicants)");
            System.out.println("--- Applicant Actions (Inherited) ---");
            System.out.println(" 6. View Available BTO Projects");
            System.out.println(" 7. Apply for BTO Project");
            System.out.println(" 8. View My Application Status");
            System.out.println(" 9. Request Application Withdrawal");
            System.out.println("10. Submit Enquiry");
            System.out.println("11. View My Enquiries");
            System.out.println("12. Edit My Enquiry");
            System.out.println("13. Delete My Enquiry");
            System.out.println("--- Common Actions ---");
            System.out.println("14. Apply/Clear Project Filters");
            System.out.println("15. Change Password");
            System.out.println(" 0. Logout");
            System.out.println("========================================");

            int choice = getMenuChoice(0, 15);

            switch (choice) {
                case 1:
                    officerController.registerForProject();
                    break;
                case 2:
                    officerController.viewRegistrationStatus();
                    break;
                case 3:
                    officerController.viewHandlingProjectDetails();
                    break;
                case 4:
                    officerController.viewAndReplyToEnquiries();
                    break;
                case 5:
                    officerController.manageFlatBooking();
                    break;
                case 6:
                    officerController.viewOpenProjects();
                    break;
                case 7:
                    officerController.applyForProject();
                    break;
                case 8:
                    officerController.viewMyApplication();
                    break;
                case 9:
                    officerController.requestWithdrawal();
                    break;
                case 10:
                    officerController.submitEnquiry();
                    break;
                case 11:
                    officerController.viewMyEnquiries();
                    break;
                case 12:
                    officerController.editMyEnquiry();
                    break;
                case 13:
                    officerController.deleteMyEnquiry();
                    break;
                case 14:
                    applyFilters();
                    break;
                case 15:
                    if (changePassword()) {
                        logout = true;
                    }
                    break;
                case 0:
                    logout = true;
                    System.out.println("Logging out...");
                    break;
                default:
                    System.out.println("Invalid choice.");
                    break;
            }
            if (!logout && choice != 0) {
                pause();
            }
        }
    }
}
```

Models\Applicant.java (141)
```java
/**
 * Represents an Applicant user in the BTO system
 * Extends the base User class and adds attributes related to BTO applications
 * such as the project applied for, application status, and booked flat type
 *
 * @author Jun Yang
 */
package Models;

import Enums.MaritalStatus;
import Enums.UserRole;
import Enums.ApplicationStatus;
import Enums.FlatType;

public class Applicant extends User {
    private String appliedProjectName;
    private ApplicationStatus applicationStatus;
    private FlatType bookedFlatType;

    /**
     * Constructs a new Applicant object
     *
     * @param nric          The applicant's NRIC. Must not be null
     * @param password      The applicant's password. Must not be null
     * @param name          The applicant's name. Must not be null
     * @param age           The applicant's age
     * @param maritalStatus The applicant's marital status. Must not be null
     * @throws IllegalArgumentException if any required field is null
     */
    public Applicant(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        super(nric, password, name, age, maritalStatus);
        this.applicationStatus = null;
        this.appliedProjectName = null;
        this.bookedFlatType = null;
    }

    /**
     * Gets the user's role
     * 
     * @return The user role enum
     */
    @Override
    public UserRole getRole() {
        return UserRole.APPLICANT;
    }

    /**
     * Gets the name of the project the applicant has applied for
     * 
     * @return The project name string
     */
    public String getAppliedProjectName() {
        return appliedProjectName;
    }

    /**
     * Sets the name of the project the applicant has applied for
     * 
     * @param appliedProjectName The project name string
     */
    public void setAppliedProjectName(String appliedProjectName) {
        this.appliedProjectName = appliedProjectName;
    }

    /**
     * Gets the application status of the applicant
     * 
     * @return The application status enum
     */
    public ApplicationStatus getApplicationStatus() {
        return applicationStatus;
    }

    /**
     * Sets the application status of the applicant
     * 
     * @param applicationStatus The application status enum
     */
    public void setApplicationStatus(ApplicationStatus applicationStatus) {
        this.applicationStatus = applicationStatus;
    }

    /**
     * Gets the booked flat type of the applicant
     * 
     * @return The booked flat type enum
     */
    public FlatType getBookedFlatType() {
        return bookedFlatType;
    }

    /**
     * Sets the booked flat type of the applicant
     * 
     * @param bookedFlatType The booked flat type enum
     */
    public void setBookedFlatType(FlatType bookedFlatType) {
        this.bookedFlatType = bookedFlatType;
    }

    /**
     * Checks if the applicant has an active application
     * 
     * @return true if the application status is PENDING or SUCCESSFUL, false
     *         otherwise
     */
    public boolean hasActiveApplication() {
        return this.applicationStatus == ApplicationStatus.PENDING ||
                this.applicationStatus == ApplicationStatus.SUCCESSFUL;
    }

    /**
     * Check if the applicant has a pending withdrawal
     *
     * @return true if the application status is PENDING_WITHDRAWAL, false otherwise
     */
    public boolean hasPendingWithdrawal() {
        return this.applicationStatus == ApplicationStatus.PENDING_WITHDRAWAL;
    }

    /**
     * Checks if the applicant has booked a flat
     * 
     * @return true if the application status is BOOKED and booked flat type is not
     *         null, false otherwise
     */
    public boolean hasBooked() {
        return this.applicationStatus == ApplicationStatus.BOOKED && this.bookedFlatType != null;
    }

    /**
     * Clears the application state of the applicant
     * Resets the applied project name, application status, and booked flat type to
     * null
     */
    public void clearApplicationState() {
        this.appliedProjectName = null;
        this.applicationStatus = null;
        this.bookedFlatType = null;
    }
}
```

Views\BaseView.java (135)
```java
/**
 * Abstract base class for all view components in the BTO application.
 * Provides common elements like the Scanner, current User, associated BaseController,
 * and AuthController. Includes helper methods for getting menu choices, changing passwords,
 * applying filters via the controller, and pausing execution.
 *
 * @author Jun Yang
 */
package Views;

import java.util.Scanner;

import Models.User;

import Controllers.BaseController;
import Controllers.AuthController;

public abstract class BaseView {
    protected final Scanner scanner;
    protected final User currentUser;
    protected final BaseController controller;
    protected final AuthController authController;

    /**
     * Constructs a new BaseView.
     *
     * @param scanner        Scanner instance for reading user input.
     * @param currentUser    The currently logged-in User object.
     * @param controller     The BaseController associated with this view's role.
     * @param authController Controller for authentication tasks (like password
     *                       change).
     */
    public BaseView(Scanner scanner, User currentUser, BaseController controller, AuthController authController) {
        this.scanner = scanner;
        this.currentUser = currentUser;
        this.controller = controller;
        this.authController = authController;
    }

    /**
     * Abstract method that must be implemented by subclasses to display the
     * specific menu
     * options relevant to the user's role and handle user choices by calling
     * controller methods.
     */
    public abstract void displayMenu();

    /**
     * Prompts the user to enter a menu choice (integer) within a specified range.
     * Handles invalid input (non-numeric, out of range) and reprompts until a valid
     * choice is entered.
     *
     * @param min The minimum valid menu choice number (inclusive).
     * @param max The maximum valid menu choice number (inclusive).
     * @return The validated integer menu choice entered by the user.
     */
    protected int getMenuChoice(int min, int max) {
        int choice = -1;
        while (true) {
            System.out.print("Enter your choice: ");
            String input = scanner.nextLine();
            try {
                choice = Integer.parseInt(input);
                if (choice >= min && choice <= max) {
                    break;
                } else {
                    System.out.println("Invalid choice. Please enter a number between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a number.");
            }
        }
        return choice;
    }

    /**
     * Handles the user interface flow for changing the password.
     * Prompts for the current password, new password, and confirmation.
     * Performs basic validation (passwords match, not empty, not same as old).
     * Calls the
     * {@link Controllers.AuthController#changePassword(Models.User, String, String)}
     * method to perform the change.
     *
     * @return true if the password change was initiated successfully by the
     *         AuthController (usually indicates user should be logged out), false
     *         otherwise.
     */
    protected boolean changePassword() {
        System.out.println("\n--- Change Password ---");
        System.out.print("Enter current password: ");
        String oldPassword = scanner.nextLine();
        System.out.print("Enter new password: ");
        String newPassword = scanner.nextLine();
        System.out.print("Confirm new password: ");
        String confirmPassword = scanner.nextLine();

        if (!newPassword.equals(confirmPassword)) {
            System.out.println("New passwords do not match. Password not changed.");
            return false;
        }
        if (newPassword.isEmpty()) {
            System.out.println("Password cannot be empty. Password not changed.");
            return false;
        }
        if (newPassword.equals(oldPassword)) {
            System.out.println("New password cannot be the same as the old password. Password not changed.");
            return false;
        }

        boolean success = authController.changePassword(currentUser, oldPassword, newPassword);
        return success;
    }

    /**
     * Calls the `applyFilters` method on the associated BaseController instance,
     * allowing the user to set or clear project view filters (location, flat type).
     */
    protected void applyFilters() {
        if (controller != null) {
            controller.applyFilters();
        } else {
            System.out.println("Error: Controller not available for filtering.");
        }
    }

    /**
     * Pauses execution and waits for the user to press Enter before continuing.
     * Used to allow users to read output before the screen clears or the menu
     * redisplays.
     */
    protected void pause() {
        System.out.println("\nPress Enter to continue...");
        scanner.nextLine();
    }
}
```

Controllers\ApplicantController.java (131)
```java
/**
 * Main controller for the Applicant role.
 * It doesn't implement actions directly but delegates them to specialized sub-controllers:
 * - {@link ApplicantActionController} for core application actions.
 * - {@link EnquiryApplicantController} for enquiry-related actions.
 * Inherits common functionality and state (like filters) from {@link BaseController}.
 *
 * @author Jordon
 */
package Controllers;

import java.util.Scanner;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

public class ApplicantController extends BaseController {

    private final ApplicantActionController actionController;
    private final EnquiryApplicantController enquiryController;

    /**
     * Constructs a new ApplicantController.
     * Instantiates and holds references to the specialized action and enquiry
     * controllers.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access (needed by
     *                                   EnquiryApplicantController).
     * @param currentUser                The currently logged-in User (expected to
     *                                   be Applicant).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public ApplicantController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner,
                authController);

        this.actionController = new ApplicantActionController(userService, projectService, applicationService,
                officerRegistrationService, currentUser, scanner, authController);
        this.enquiryController = new EnquiryApplicantController(userService, projectService, applicationService,
                officerRegistrationService, enquiryService, currentUser, scanner, authController);

    }

    /**
     * Delegates the action to view open projects to the ApplicantActionController.
     * 
     * @see ApplicantActionController#viewOpenProjects()
     */
    public void viewOpenProjects() {
        actionController.viewOpenProjects();
    }

    /**
     * Delegates the action to apply for a project to the ApplicantActionController.
     * 
     * @see ApplicantActionController#applyForProject()
     */
    public void applyForProject() {
        actionController.applyForProject();
    }

    /**
     * Delegates the action to view the applicant's application status to the
     * ApplicantActionController.
     * 
     * @see ApplicantActionController#viewMyApplication()
     */
    public void viewMyApplication() {
        actionController.viewMyApplication();
    }

    /**
     * Delegates the action to request application withdrawal to the
     * ApplicantActionController.
     * 
     * @see ApplicantActionController#requestWithdrawal()
     */
    public void requestWithdrawal() {
        actionController.requestWithdrawal();
    }

    /**
     * Delegates the action to submit an enquiry to the EnquiryApplicantController.
     * 
     * @see EnquiryApplicantController#submitEnquiry()
     */
    public void submitEnquiry() {
        enquiryController.submitEnquiry();
    }

    /**
     * Delegates the action to view the applicant's enquiries to the
     * EnquiryApplicantController.
     * 
     * @see EnquiryApplicantController#viewMyEnquiries()
     */
    public void viewMyEnquiries() {
        enquiryController.viewMyEnquiries();
    }

    /**
     * Delegates the action to edit an enquiry to the EnquiryApplicantController.
     * 
     * @see EnquiryApplicantController#editMyEnquiry()
     */
    public void editMyEnquiry() {
        enquiryController.editMyEnquiry();
    }

    /**
     * Delegates the action to delete an enquiry to the EnquiryApplicantController.
     * 
     * @see EnquiryApplicantController#deleteMyEnquiry()
     */
    public void deleteMyEnquiry() {
        enquiryController.deleteMyEnquiry();
    }

}
```

Views\ManagerView.java (128)
```java
/**
 * View component responsible for displaying the menu and handling input for the HDB Manager role.
 * Interacts with the {@link Controllers.ManagerController} to execute actions covering project management,
 * staff/application management, reporting, and enquiry oversight.
 *
 * @author Jun Yang
 */
package Views;

import java.util.Scanner;
import Models.User;
import Controllers.ManagerController;
import Controllers.AuthController;

public class ManagerView extends BaseView {
    private final ManagerController managerController;

    /**
     * Constructs a new ManagerView.
     *
     * @param scanner        Scanner instance for reading user input.
     * @param currentUser    The currently logged-in User (expected to be
     *                       HDBManager).
     * @param controller     The ManagerController associated with this view.
     * @param authController Controller for authentication tasks.
     */
    public ManagerView(Scanner scanner, User currentUser, ManagerController controller, AuthController authController) {
        super(scanner, currentUser, controller, authController);
        this.managerController = controller;
    }

    /**
     * Displays the main menu for the HDB Manager role.
     * Presents options grouped by function: Project Management, Staff and Application
     * Management,
     * Reporting and Enquiries, and Common Actions (filters, password change, logout).
     * Reads user input and calls the corresponding methods on the ManagerController
     * or BaseView helpers.
     * Loops until the user chooses to logout.
     */
    @Override
    public void displayMenu() {
        boolean logout = false;
        while (!logout) {
            System.out.println("\n=========== HDB Manager Menu ===========");
            System.out.println("Welcome, Manager " + currentUser.getName() + "!");
            System.out.println("--- Project Management ---");
            System.out.println(" 1. Create New BTO Project");
            System.out.println(" 2. Edit My Project Details");
            System.out.println(" 3. Delete My Project");
            System.out.println(" 4. Toggle Project Visibility");
            System.out.println(" 5. View All Projects");
            System.out.println(" 6. View My Managed Projects");
            System.out.println("--- Staff & Application Management ---");
            System.out.println(" 7. Manage Officer Registrations (Approve/Reject)");
            System.out.println(" 8. Manage BTO Applications (Approve/Reject)");
            System.out.println(" 9. Manage Withdrawal Requests (Approve/Reject)");
            System.out.println("--- Reporting & Enquiries ---");
            System.out.println("10. Generate Applicant Report (Booked Flats)");
            System.out.println("11. View Enquiries (All Projects)");
            System.out.println("12. View/Reply Enquiries (My Managed Projects)");
            System.out.println("--- Common Actions ---");
            System.out.println("13. Apply/Clear Project Filters (Affects Views 5, 6, 10, 12)");
            System.out.println("14. Change Password");
            System.out.println(" 0. Logout");
            System.out.println("========================================");

            int choice = getMenuChoice(0, 14);

            switch (choice) {
                case 1:
                    managerController.createProject();
                    break;
                case 2:
                    managerController.editProject();
                    break;
                case 3:
                    managerController.deleteProject();
                    break;
                case 4:
                    managerController.toggleProjectVisibility();
                    break;
                case 5:
                    managerController.viewAllProjects();
                    break;
                case 6:
                    managerController.viewMyProjects();
                    break;
                case 7:
                    managerController.manageOfficerRegistrations();
                    break;
                case 8:
                    managerController.manageApplications();
                    break;
                case 9:
                    managerController.manageWithdrawalRequests();
                    break;
                case 10:
                    managerController.generateApplicantReport();
                    break;
                case 11:
                    managerController.viewAllEnquiries();
                    break;
                case 12:
                    managerController.viewAndReplyToManagedEnquiries();
                    break;
                case 13:
                    applyFilters();
                    break;
                case 14:
                    if (changePassword()) {
                        logout = true;
                    }
                    break;
                case 0:
                    logout = true;
                    System.out.println("Logging out...");
                    break;
                default:
                    System.out.println("Invalid choice.");
                    break;
            }
            if (!logout && choice != 0) {
                pause();
            }
        }
    }
}
```

Models\OfficerRegistration.java (126)
```java
/**
 * Represents a registration request made by an HDB Officer to handle a specific BTO project.
 *
 * @author Jun Yang
 */
package Models;

import Enums.OfficerRegistrationStatus;
import java.util.Date;

public class OfficerRegistration {
    private final String registrationId;
    private final String officerNric;
    private final String projectName;
    private OfficerRegistrationStatus status;
    private final Date registrationDate;

    /**
     * Constructs a new OfficerRegistration when an officer first registers for a
     * project.
     * The registration ID is automatically generated based on NRIC and project
     * name.
     * Initial status is set to PENDING.
     *
     * @param officerNric      The NRIC of the officer. Cannot be null.
     * @param projectName      The name of the project being registered for. Cannot
     *                         be null.
     * @param registrationDate The date the registration was submitted. Cannot be
     *                         null.
     * @throws IllegalArgumentException if any parameter is null.
     */
    public OfficerRegistration(String officerNric, String projectName, Date registrationDate) {
        if (officerNric == null || projectName == null || registrationDate == null) {
            throw new IllegalArgumentException("OfficerRegistration fields cannot be null");
        }
        this.registrationId = officerNric + "_REG_" + projectName;
        this.officerNric = officerNric;
        this.projectName = projectName;
        this.status = OfficerRegistrationStatus.PENDING;
        this.registrationDate = registrationDate;
    }

    /**
     * Constructs a new OfficerRegistration when an officer first registers for a
     * project.
     * The registration ID is automatically generated based on NRIC and project
     * name.
     * Initial status is set to PENDING.
     *
     * @param officerNric      The NRIC of the HDB Officer registering. Cannot be
     *                         null.
     * @param projectName      The name of the project being registered for. Cannot
     *                         be null.
     * @param registrationDate The date the registration was submitted. Cannot be
     *                         null.
     * @throws IllegalArgumentException if any parameter is null.
     */
    public OfficerRegistration(String registrationId, String officerNric, String projectName,
            OfficerRegistrationStatus status, Date registrationDate) {
        if (registrationId == null || officerNric == null || projectName == null || status == null
                || registrationDate == null) {
            throw new IllegalArgumentException("Required OfficerRegistration fields cannot be null when loading");
        }
        this.registrationId = registrationId;
        this.officerNric = officerNric;
        this.projectName = projectName;
        this.status = status;
        this.registrationDate = registrationDate;
    }

    /**
     * Gets the registration ID.
     *
     * @return The registration ID string.
     */
    public String getRegistrationId() {
        return registrationId;
    }

    /**
     * Gets the NRIC of the officer.
     *
     * @return The officer's NRIC string.
     */
    public String getOfficerNric() {
        return officerNric;
    }

    /**
     * Gets the name of the project the officer is registering for.
     *
     * @return The project name string.
     */
    public String getProjectName() {
        return projectName;
    }

    /**
     * Gets the status of the registration.
     *
     * @return The registration status enum.
     */
    public OfficerRegistrationStatus getStatus() {
        return status;
    }

    /**
     * Gets the date the registration was submitted.
     *
     * @return The registration date.
     */
    public Date getRegistrationDate() {
        return registrationDate;
    }

    /**
     * Sets the status of the registration.
     *
     * @param status The registration status enum. Cannot be null.
     */
    public void setStatus(OfficerRegistrationStatus status) {
        if (status != null) {
            this.status = status;
        }
    }
}
```

Models\FlatTypeDetails.java (121)
```java
/**
 * Represents the details associated with a specific flat type within a BTO project,
 * including the total number of units, the number currently available, and the selling price.
 *
 * @author Jun Yang
 */

package Models;

public class FlatTypeDetails {
    private final int totalUnits;
    private int availableUnits;
    private double sellingPrice;

    /**
     * Constructor for FlatTypeDetails.
     *
     * @param totalUnits     The total number of units available for this flat type
     * @param availableUnits The number of units currently available for sale
     * @param sellingPrice   The selling price of the flat type
     * @throws IllegalArgumentException if any of the parameters are invalid
     */
    public FlatTypeDetails(int totalUnits, int availableUnits, double sellingPrice) {
        if (totalUnits < 0 || availableUnits < 0 || availableUnits > totalUnits || sellingPrice < 0) {
            throw new IllegalArgumentException("Invalid FlatTypeDetails parameters: total=" + totalUnits
                    + ", available=" + availableUnits + ", price=" + sellingPrice);
        }
        this.totalUnits = totalUnits;
        this.availableUnits = availableUnits;
        this.sellingPrice = sellingPrice;
    }

    /**
     * Gets the total number of units for this flat type.
     * 
     * @return The total unit count.
     */
    public int getTotalUnits() {
        return totalUnits;
    }

    /**
     * Gets the number of available units for this flat type.
     * 
     * @return The available unit count.
     */

    public int getAvailableUnits() {
        return availableUnits;
    }

    /**
     * Gets the selling price of this flat type.
     * 
     * @return The selling price.
     */

    public double getSellingPrice() {
        return sellingPrice;
    }

    /**
     * Sets the selling price of this flat type.
     * 
     * @param sellingPrice The new selling price.
     */
    public void setSellingPrice(double sellingPrice) {
        if (sellingPrice >= 0) {
            this.sellingPrice = sellingPrice;
        } else {
            System.err.println("Warning: Attempted to set negative selling price.");
        }
    }

    /**
     * Decrements the number of available units by one.
     * 
     * @return true if the decrement was successful, false if no units were
     *         available to decrement.
     */
    public boolean decrementAvailableUnits() {
        if (this.availableUnits > 0) {
            this.availableUnits--;
            return true;
        } else {
            System.err.println("Warning: Attempted to decrement zero available units.");
            return false;
        }
    }

    /**
     * Increments the number of available units by one.
     * 
     * @return true if the increment was successful, false if it would exceed total
     *         units.
     */
    public boolean incrementAvailableUnits() {
        if (this.availableUnits < this.totalUnits) {
            this.availableUnits++;
            return true;
        } else {
            System.err.println("Warning: Attempted to increment available units beyond total units.");
            return false;
        }
    }

    /**
     * Sets the number of available units for this flat type.
     * 
     * @param availableUnits The new number of available units.
     */
    public void setAvailableUnits(int availableUnits) {
        if (availableUnits >= 0 && availableUnits <= this.totalUnits) {
            this.availableUnits = availableUnits;
        } else {
            System.err.println("Error: Invalid available units (" + availableUnits + ") set for flat type with total "
                    + this.totalUnits + ". Clamping to valid range [0, " + this.totalUnits + "].");
            this.availableUnits = Math.max(0, Math.min(availableUnits, this.totalUnits));
        }
    }
}
```

Services\IOfficerRegistrationService.java (117)
```java
/**
 * Interface defining the contract for HDB Officer project registration management services.
 * Specifies methods for loading, saving, finding, retrieving, adding, and removing registrations.
 *
 * @author Kishore Kumar
 */
package Services;

import java.util.List;
import java.util.Map;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Enums.OfficerRegistrationStatus;

public interface IOfficerRegistrationService {
    /**
     * Loads officer registration data from persistent storage (e.g., CSV file).
     * Requires user and project data for validation (e.g., checking officer NRIC,
     * project existence).
     * Populates the service's internal registration map.
     * 
     * @param users    A map of NRIC to User objects, used for validating officer
     *                 NRICs.
     * @param projects A list of all Project objects, used for validating project
     *                 names.
     * @return A map of RegistrationID to OfficerRegistration objects representing
     *         all loaded registrations.
     */
    Map<String, OfficerRegistration> loadOfficerRegistrations(Map<String, User> users, List<Project> projects);

    /**
     * Saves the provided map of officer registrations to persistent storage.
     * Overwrites the existing registration data file.
     * 
     * @param registrations A map of RegistrationID to OfficerRegistration objects
     *                      to be saved.
     */
    void saveOfficerRegistrations(Map<String, OfficerRegistration> registrations);

    /**
     * Finds an officer registration by its unique ID.
     * 
     * @param registrationId The ID of the registration to find.
     * @return The OfficerRegistration object if found, or null otherwise.
     */
    OfficerRegistration findRegistrationById(String registrationId);

    /**
     * Retrieves a list of all registrations (regardless of status) made by a
     * specific HDB Officer.
     * 
     * @param officerNric The NRIC of the officer.
     * @return A list of OfficerRegistration objects for the specified officer.
     *         Returns an empty list if NRIC is null or no registrations are found.
     */
    List<OfficerRegistration> getRegistrationsByOfficer(String officerNric);

    /**
     * Retrieves a list of all registrations (regardless of status) associated with
     * a specific project.
     * 
     * @param projectName The name of the project.
     * @return A list of OfficerRegistration objects for the specified project.
     *         Returns an empty list if projectName is null or no registrations are
     *         found.
     */
    List<OfficerRegistration> getRegistrationsByProject(String projectName);

    /**
     * Retrieves a list of all officer registrations that currently have a specific
     * status.
     * 
     * @param status The OfficerRegistrationStatus to filter by.
     * @return A list of OfficerRegistration objects with the specified status.
     *         Returns an empty list if status is null or no registrations match.
     */
    List<OfficerRegistration> getRegistrationsByStatus(OfficerRegistrationStatus status);

    /**
     * Finds the specific registration record indicating which project an officer is
     * currently approved to handle.
     * Assumes an officer can only be actively approved for one project at a time.
     * 
     * @param officerNric The NRIC of the officer.
     * @return The OfficerRegistration object with APPROVED status for the officer,
     *         or null if none is found.
     */
    OfficerRegistration getApprovedRegistrationForOfficer(String officerNric);

    /**
     * Adds a new officer registration to the service's internal map.
     * Should perform checks to prevent adding duplicates (based on registration
     * ID).
     * 
     * @param registration The OfficerRegistration object to add.
     */
    void addRegistration(OfficerRegistration registration);

    /**
     * Removes an officer registration from the service's internal map based on its
     * ID.
     * 
     * @param registrationId The ID of the registration to remove.
     * @return true if the registration was found and removed, false otherwise.
     */
    boolean removeRegistration(String registrationId);

    /**
     * Retrieves a map containing all officer registrations currently managed by the
     * service.
     * Implementations should consider returning a copy.
     * 
     * @return A map of RegistrationID to OfficerRegistration objects.
     */
    Map<String, OfficerRegistration> getAllRegistrations();
}
```

Controllers\OfficerController.java (113)
```java
/**
 * Main controller for the HDB Officer role.
 * It inherits from {@link ApplicantController} to provide standard applicant functionalities
 * (like applying for projects, managing own applications/enquiries).
 * It also delegates officer-specific actions to specialized sub-controllers:
 * - {@link OfficerActionController} for registration and status viewing.
 * - {@link EnquiryOfficerController} for handling enquiries related to the assigned project.
 * - {@link BookingOfficerController} for managing the flat booking process.
 *
 * @author Patrick
 */
package Controllers;

import java.util.Scanner;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

public class OfficerController extends ApplicantController {

    private final OfficerActionController officerActionController;
    private final EnquiryOfficerController enquiryOfficerController;
    private final BookingOfficerController bookingOfficerController;

    /**
     * Constructs a new OfficerController.
     * Calls the superclass (ApplicantController) constructor to initialize base and
     * applicant-specific components.
     * Instantiates and holds references to the specialized officer action, enquiry,
     * and booking controllers.
     *
     * @param userService                Service for user data access.
     * @param projectService             Service for project data access.
     * @param applicationService         Service for application data access.
     * @param officerRegistrationService Service for officer registration data
     *                                   access.
     * @param enquiryService             Service for enquiry data access (needed by
     *                                   both Applicant and Officer parts).
     * @param currentUser                The currently logged-in User (expected to
     *                                   be HDBOfficer).
     * @param scanner                    Scanner instance for reading user input.
     * @param authController             Controller for authentication tasks.
     */
    public OfficerController(IUserService userService, IProjectService projectService,
            IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
            IEnquiryService enquiryService,
            User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser,
                scanner, authController);

        this.officerActionController = new OfficerActionController(userService, projectService, applicationService,
                officerRegistrationService, currentUser, scanner, authController);
        this.enquiryOfficerController = new EnquiryOfficerController(userService, projectService, applicationService,
                officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.bookingOfficerController = new BookingOfficerController(userService, projectService, applicationService,
                officerRegistrationService, currentUser, scanner, authController);
    }

    /**
     * Delegates the action to register for a project to the
     * OfficerActionController.
     * 
     * @see OfficerActionController#registerForProject()
     */
    public void registerForProject() {
        officerActionController.registerForProject();
    }

    /**
     * Delegates the action to view registration status to the
     * OfficerActionController.
     * 
     * @see OfficerActionController#viewRegistrationStatus()
     */
    public void viewRegistrationStatus() {
        officerActionController.viewRegistrationStatus();
    }

    /**
     * Delegates the action to view details of the handling project to the
     * OfficerActionController.
     * 
     * @see OfficerActionController#viewHandlingProjectDetails()
     */
    public void viewHandlingProjectDetails() {
        officerActionController.viewHandlingProjectDetails();
    }

    /**
     * Delegates the action to view and reply to enquiries for the handling project
     * to the EnquiryOfficerController.
     * Note: This is the Officer-specific version, distinct from the applicant's
     * "viewMyEnquiries".
     * 
     * @see EnquiryOfficerController#viewAndReplyToEnquiries()
     */
    public void viewAndReplyToEnquiries() {
        enquiryOfficerController.viewAndReplyToEnquiries();
    }

    /**
     * Delegates the action to manage flat bookings to the BookingOfficerController.
     * 
     * @see BookingOfficerController#manageFlatBooking()
     */
    public void manageFlatBooking() {
        bookingOfficerController.manageFlatBooking();
    }

}
```

Views\ApplicantView.java (110)
```java
/**
 * View component responsible for displaying the menu and handling input for the Applicant role.
 * Interacts with the {@link Controllers.ApplicantController} to execute actions.
 *
 * @author Jun Yang
 */

package Views;

import java.util.Scanner;
import Models.User;

import Controllers.ApplicantController;
import Controllers.AuthController;

public class ApplicantView extends BaseView {
    private final ApplicantController applicantController;
    
    /**
     * Constructs a new ApplicantView.
     *
     * @param scanner        Scanner instance for reading user input.
     * @param currentUser    The currently logged-in User (expected to be
     *                       Applicant).
     * @param controller     The ApplicantController associated with this view.
     * @param authController Controller for authentication tasks.
     */
    public ApplicantView(Scanner scanner, User currentUser, ApplicantController controller,
            AuthController authController) {
        super(scanner, currentUser, controller, authController);
        this.applicantController = controller;
    }

    /**
     * Displays the main menu for the Applicant role.
     * Presents options for viewing/applying for projects, managing applications and
     * enquiries,
     * applying filters, changing password, and logging out.
     * Reads user input and calls the corresponding methods on the
     * ApplicantController or BaseView helpers.
     * Loops until the user chooses to logout.
     */
    @Override
    public void displayMenu() {
        boolean logout = false;
        while (!logout) {
            System.out.println("\n=========== Applicant Menu ===========");
            System.out.println("Welcome, " + currentUser.getName() + "!");
            System.out.println("1. View Available BTO Projects");
            System.out.println("2. Apply for BTO Project");
            System.out.println("3. View My Application Status");
            System.out.println("4. Request Application Withdrawal");
            System.out.println("5. Submit Enquiry");
            System.out.println("6. View My Enquiries");
            System.out.println("7. Edit My Enquiry");
            System.out.println("8. Delete My Enquiry");
            System.out.println("9. Apply/Clear Project Filters");
            System.out.println("10. Change Password");
            System.out.println("0. Logout");
            System.out.println("======================================");

            int choice = getMenuChoice(0, 10);

            switch (choice) {
                case 1:
                    applicantController.viewOpenProjects();
                    break;
                case 2:
                    applicantController.applyForProject();
                    break;
                case 3:
                    applicantController.viewMyApplication();
                    break;
                case 4:
                    applicantController.requestWithdrawal();
                    break;
                case 5:
                    applicantController.submitEnquiry();
                    break;
                case 6:
                    applicantController.viewMyEnquiries();
                    break;
                case 7:
                    applicantController.editMyEnquiry();
                    break;
                case 8:
                    applicantController.deleteMyEnquiry();
                    break;
                case 9:
                    applyFilters();
                    break;
                case 10:
                    if (changePassword()) {
                        logout = true;
                    }
                    break;
                case 0:
                    logout = true;
                    System.out.println("Logging out...");
                    break;
                default:
                    System.out.println("Invalid choice.");
                    break;
            }
            if (!logout && choice != 0) {
                pause();
            }
        }
    }
}
```

Services\IApplicationService.java (106)
```java
/**
 * Interface defining the contract for BTO application data management services.
 * Specifies methods for loading, saving, finding, retrieving, adding, and removing applications.
 *
 * @author Kishore Kumar
 */
package Services;

import java.util.List;
import java.util.Map;
import Models.BTOApplication;
import Models.Project;
import Enums.ApplicationStatus;

public interface IApplicationService {
    /**
     * Loads BTO application data from persistent storage (e.g., CSV file).
     * 
     * @param projects A list of all Project objects, used for unit count
     *                 adjustments.
     * @return A map of ApplicationID to BTOApplication objects representing all
     *         loaded applications.
     */
    Map<String, BTOApplication> loadApplications(List<Project> projects);

    /**
     * Saves the provided map of BTO applications to persistent storage.
     * Overwrites the existing application data file.
     * 
     * @param applications A map of ApplicationID to BTOApplication objects to be
     *                     saved.
     */
    void saveApplications(Map<String, BTOApplication> applications);

    /**
     * Finds a BTO application by its unique ID.
     * 
     * @param applicationId The ID of the application to find.
     * @return The BTOApplication object if found, or null otherwise.
     */
    BTOApplication findApplicationById(String applicationId);

    /**
     * Finds a specific BTO application based on the applicant's NRIC and the
     * project name.
     * Assumes a standard Application ID format (e.g., NRIC_ProjectName).
     * 
     * @param nric        The NRIC of the applicant.
     * @param projectName The name of the project.
     * @return The BTOApplication object if found, or null otherwise.
     */
    BTOApplication findApplicationByApplicantAndProject(String nric, String projectName);

    /**
     * Retrieves a list of all BTO applications submitted for a specific project.
     * 
     * @param projectName The name of the project.
     * @return A list of BTOApplication objects for the specified project. Returns
     *         an empty list if projectName is null or no applications are found.
     */
    List<BTOApplication> getApplicationsByProject(String projectName);

    /**
     * Retrieves a list of all BTO applications that currently have a specific
     * status.
     * 
     * @param status The ApplicationStatus to filter by.
     * @return A list of BTOApplication objects with the specified status. Returns
     *         an empty list if status is null or no applications match.
     */
    List<BTOApplication> getApplicationsByStatus(ApplicationStatus status);

    /**
     * Retrieves a list of all BTO applications submitted by a specific applicant.
     * 
     * @param nric The NRIC of the applicant.
     * @return A list of BTOApplication objects submitted by the specified
     *         applicant. Returns an empty list if nric is null or no applications
     *         are found.
     */
    List<BTOApplication> getApplicationsByApplicant(String nric);

    /**
     * Adds a new BTO application to the service's internal map.
     * Should perform checks to prevent adding duplicates (based on application ID).
     * 
     * @param application The BTOApplication object to add.
     */
    void addApplication(BTOApplication application);

    /**
     * Removes a BTO application from the service's internal map based on its ID.
     * 
     * @param applicationId The ID of the application to remove.
     * @return true if the application was found and removed, false otherwise.
     */
    boolean removeApplication(String applicationId);

    /**
     * Retrieves a map containing all BTO applications currently managed by the
     * service.
     * 
     * @return A map of ApplicationID to BTOApplication objects.
     */
    Map<String, BTOApplication> getAllApplications();
}
```

Models\User.java (105)
```java
/**
 * Abstract base class representing a user in the BTO system
 * Contains common attributes like NRIC, password, name, age, and marital status
 * Subclasses define specific roles (Applicant, HDBOfficer, HDBManager)
 *
 * @author Jun Yang
 */
package Models;

import Enums.MaritalStatus;
import Enums.UserRole;

public abstract class User {
    private final String nric;
    private String password;
    private final String name;
    private final int age;
    private final MaritalStatus maritalStatus;

    /**
     * Constructs a new User object
     *
     * @param nric The user's NRIC Must not be null
     * @param password The user's password. Must not be null
     * @param name The user's name. Must not be null
     * @param age The user's age
     * @param maritalStatus The user's marital status. Must not be null
     * @throws IllegalArgumentException if any required field is null
     */
    public User(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        if (nric == null || password == null || name == null || maritalStatus == null) {
            throw new IllegalArgumentException("User fields cannot be null");
        }
        this.nric = nric;
        this.password = password;
        this.name = name;
        this.age = age;
        this.maritalStatus = maritalStatus;
    }

    /**
     * Gets the user's NRIC.
     * 
     * @return The NRIC string.
     */
    public String getNric() {
        return nric;
    }

    /**
     * Gets the user's password.
     * 
     * @return The password string.
     */
    public String getPassword() {
        return password;
    }

    /**
     * Gets the user's name.
     * 
     * @return The name string.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the user's age.
     * 
     * @return The age integer.
     */
    public int getAge() {
        return age;
    }

    /**
     * Gets the user's marital status.
     * 
     * @return The marital status enum.
     */
    public MaritalStatus getMaritalStatus() {
        return maritalStatus;
    }

    /**
     * Sets the user's password.
     * 
     * @param password The new password string.
     */
    public void setPassword(String password) {
        if (password != null && !password.isEmpty()) {
            this.password = password;
        } else {
            System.err.println("Warning: Attempted to set null or empty password for NRIC: " + nric);
        }
    }

    /**
     * Abstract method to get the user's role.
     * 
     * @return The user role enum.
     */
    public abstract UserRole getRole();
}
```

Controllers\AuthController.java (94)
```java
/**
 * Controller responsible for handling user authentication (login) and password changes.
 * Interacts with the UserService to validate credentials and update user data.
 *
 * @author Kai Wang
 */
package Controllers;

import Models.User;
import Services.DataService;
import Services.IUserService;
import Utils.NricValidator;

public class AuthController {
    private final IUserService userService;

    /**
     * Constructs a new AuthController.
     *
     * @param userService The user service instance used for retrieving and
     *                    potentially saving user data.
     */
    public AuthController(IUserService userService) {
        this.userService = userService;
    }

    /**
     * Attempts to log in a user based on provided NRIC and password.
     * Validates the NRIC format first.
     * Checks against user data retrieved from the UserService.
     *
     * @param nric     The NRIC entered by the user.
     * @param password The password entered by the user.
     * @return The User object if login is successful, null otherwise (prints error
     *         messages for invalid NRIC, user not found, or incorrect password).
     */
    public User login(String nric, String password) {
        if (!NricValidator.isValidNric(nric)) {
            System.out.println("Invalid NRIC format.");
            return null;
        }
        User user = userService.findUserByNric(nric);
        if (user != null && user.getPassword().equals(password)) {
            return user;
        } else if (user != null) {
            System.out.println("Incorrect password.");
            return null;
        } else {
            System.out.println("User NRIC not found.");
            return null;
        }
    }

    /**
     * Attempts to change the password for the given user.
     * Verifies the old password before updating to the new one.
     * Ensures the new password is not empty and different from the old password.
     * Triggers a save operation for all users via the static DataService.saveUsers
     * method upon successful change.
     *
     * @param user        The User object whose password needs changing.
     * @param oldPassword The current password provided by the user for
     *                    verification.
     * @param newPassword The desired new password.
     * @return true if the password was successfully changed and saved, false
     *         otherwise (prints error messages for incorrect old password,
     *         non-matching new passwords, empty new password, or same password).
     */
    public boolean changePassword(User user, String oldPassword, String newPassword) {
        if (user == null)
            return false;

        if (user.getPassword().equals(oldPassword)) {
            if (newPassword != null && !newPassword.isEmpty()) {
                if (newPassword.equals(oldPassword)) {
                    System.out.println("New password cannot be the same as the old password. Password not changed.");
                    return false;
                }
                user.setPassword(newPassword);

                DataService.saveUsers(userService.getAllUsers());

                System.out.println("Password changed successfully. Please log in again.");
                return true;
            } else {
                System.out.println("New password cannot be empty.");
                return false;
            }
        } else {
            System.out.println("Incorrect old password.");
            return false;
        }
    }
}
```

Services\IEnquiryService.java (78)
```java
/**
 * Interface defining the contract for enquiry data management services.
 * Specifies methods for loading, saving, finding, retrieving, adding, and removing enquiries.
 *
 * @author Kishore Kumar
 */
package Services;

import java.util.List;
import Models.Enquiry;

public interface IEnquiryService {
    /**
     * Loads enquiry data from persistent storage (e.g., CSV file).
     * Populates the service's internal enquiry list.
     * 
     * @return A list of loaded Enquiry objects.
     */
    List<Enquiry> loadEnquiries();

    /**
     * Saves the provided list of enquiries to persistent storage.
     * Overwrites the existing enquiry data file.
     * 
     * @param enquiries The list of Enquiry objects to be saved.
     */
    void saveEnquiries(List<Enquiry> enquiries);

    /**
     * Adds a new enquiry to the service's internal list.
     * Should perform checks to prevent adding duplicates (based on enquiry ID).
     * 
     * @param enquiry The Enquiry object to add.
     */
    void addEnquiry(Enquiry enquiry);

    /**
     * Removes an enquiry from the service's internal list based on its ID.
     * 
     * @param enquiryId The ID of the enquiry to remove.
     * @return true if the enquiry was found and removed, false otherwise.
     */
    boolean removeEnquiry(String enquiryId);

    /**
     * Finds an enquiry by its unique ID.
     * 
     * @param enquiryId The ID of the enquiry to find.
     * @return The Enquiry object if found, or null otherwise.
     */
    Enquiry findEnquiryById(String enquiryId);

    /**
     * Retrieves a list of all enquiries submitted by a specific applicant.
     * 
     * @param applicantNric The NRIC of the applicant.
     * @return A list of Enquiry objects submitted by the specified applicant.
     *         Returns an empty list if NRIC is null or no enquiries are found.
     */
    List<Enquiry> getEnquiriesByApplicant(String applicantNric);

    /**
     * Retrieves a list of all enquiries associated with a specific project.
     * 
     * @param projectName The name of the project.
     * @return A list of Enquiry objects for the specified project. Returns an empty
     *         list if projectName is null or no enquiries are found.
     */
    List<Enquiry> getEnquiriesByProject(String projectName);

    /**
     * Retrieves a list containing all enquiries currently managed by the service.
     * Implementations should consider returning a copy.
     * 
     * @return A list of all Enquiry objects.
     */
    List<Enquiry> getAllEnquiries();
}
```

Services\IProjectService.java (72)
```java
/**
 * Interface defining the contract for BTO project data management services.
 * Specifies methods for loading, saving, finding, retrieving, adding, and removing projects.
 *
 * @author Kishore Kumar
 */
package Services;

import java.util.List;
import java.util.Map;
import Models.Project;
import Models.User;

public interface IProjectService {
    /**
     * Loads project data from persistent storage (e.g., CSV file).
     * Requires user data for validation (e.g., checking manager NRIC).
     * Populates the service's internal project list.
     * 
     * @param users A map of NRIC to User objects, used for validation.
     * @return A list of loaded Project objects.
     */
    List<Project> loadProjects(Map<String, User> users);

    /**
     * Saves the provided list of projects to persistent storage.
     * Overwrites the existing project data file.
     * 
     * @param projects The list of Project objects to be saved.
     */
    void saveProjects(List<Project> projects);

    /**
     * Finds a project by its unique name (case-insensitive).
     * 
     * @param name The name of the project to find.
     * @return The Project object if found, or null otherwise.
     */
    Project findProjectByName(String name);

    /**
     * Retrieves a list containing all projects currently managed by the service.
     * Implementations should consider returning a copy.
     * 
     * @return A list of all Project objects.
     */
    List<Project> getAllProjects();

    /**
     * Retrieves a list of projects managed by a specific HDB Manager.
     * 
     * @param managerNric The NRIC of the manager.
     * @return A list of projects managed by the specified manager. Returns an empty
     *         list if NRIC is null or no projects are found.
     */
    List<Project> getProjectsManagedBy(String managerNric);

    /**
     * Adds a new project to the service's internal list.
     * Should perform checks to prevent adding duplicates (based on project name).
     * 
     * @param project The Project object to add.
     */
    void addProject(Project project);

    /**
     * Removes a project
     * 
     * @param project The Project object to remove.
     */
    boolean removeProject(Project project);
}
```

Enums\FlatType.java (46)
```java
/**
 * Represents the types of flats available in BTO projects
 *
 * @author Kai Wang
 */
package Enums;

public enum FlatType {
    TWO_ROOM("2-Room"), THREE_ROOM("3-Room");

    private final String displayName;

    FlatType(String displayName) {
        this.displayName = displayName;
    }

    /**
     * Gets the user-friendly display name for the flat type.
     * 
     * @return The display name (e.g., "2-Room").
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Converts a string representation of a flat type (e.g., "2-Room") into the corresponding FlatType enum constant.
     *
     * @param text The string representation of the flat type.
     * @return The matching FlatType enum constant, or null if no match is found.
     */
    public static FlatType fromString(String text) {
        if (text != null) {
            for (FlatType b : FlatType.values()) {
                if (text.trim().equalsIgnoreCase(b.name()) || text.trim().equalsIgnoreCase(b.displayName)) {
                    return b;
                }
            }
            if ("2-Room".equalsIgnoreCase(text.trim()))
                return TWO_ROOM;
            if ("3-Room".equalsIgnoreCase(text.trim()))
                return THREE_ROOM;
        }
        return null;
    }
}
```

Parsers\LSparse.java (42)
```java
/**
 * Utility class for parsing strings containing lists of items separated by a delimiter.
 * Specifically designed to handle lists stored in CSV fields, potentially with quoting.
 *
 * @author Jordon
 */
package Parsers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class LSparse {
    private static final String LIST_DELIMITER = ";";

    /**
     * Parses a string containing a list of items separated by a semicolon (';').
     * Handles cases where the entire list string might be enclosed in double quotes
     * (e.g., "\"item1;item2\"").
     * Trims whitespace from each resulting item and filters out empty strings.
     *
     * @param listString The string representation of the list (e.g., "item1; item2
     *                   ;item3" or "\"nric1;nric2\"").
     * @return A List of strings containing the parsed items, or an empty list if
     *         the input is null, empty, or contains no valid items.
     */
    public static List<String> parseListString(String listString) {
        if (listString == null || listString.trim().isEmpty()) {
            return new ArrayList<>();
        }
        String effectiveList = listString.trim();
        if (effectiveList.startsWith("\"") && effectiveList.endsWith("\"")) {
            effectiveList = effectiveList.substring(1, effectiveList.length() - 1).replace("\"\"", "\"");
        }
        return Arrays.stream(effectiveList.split(LIST_DELIMITER))
                .map(str -> str.trim())

                .filter(s -> !s.isEmpty())
                .collect(Collectors.toList());
    }
}
```

Services\IUserService.java (42)
```java
/**
 * Interface defining the contract for user data management services.
 * Specifies methods for loading, saving, finding, and retrieving user data.
 *
 * @author Kishore Kumar
 */
package Services;

import java.util.Map;
import Models.User;

public interface IUserService {
    /**
     * Loads user data from the specified data files and populates the internal user
     * map.
     * Clears existing users before loading new data.
     *
     * @return A map of user NRIC to User object.
     */
    Map<String, User> loadUsers();

    /**
     * Saves the current user data to the specified data files.
     * This method should be called to persist any changes made to the user data.
     */
    void saveUsers(Map<String, User> users);

    /**
     * Finds a user by their NRIC.
     *
     * @param nric The NRIC of the user to find.
     * @return The User object if found, null otherwise.
     */
    User findUserByNric(String nric);

    /**
     * Retrieves a map containing all users currently managed by the service.
     * 
     * @return A map of NRIC to User objects.
     */
    Map<String, User> getAllUsers();
}
```

Utils\DateUtils.java (39)
```java
/**
 * Utility class for common date-related operations.
 * Provides methods for getting the current date and formatting dates into strings.
 *
 * @author Jordon
 */
package Utils;

import java.text.SimpleDateFormat;
import java.util.Date;

public class DateUtils {
    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    /**
     * Gets the current system date and time.
     * 
     * @return A new Date object representing the current moment.
     */
    public static Date getCurrentDate() {
        return new Date();
    }

    /**
     * Formats a Date object into a string using the "yyyy-MM-dd" pattern.
     * Uses strict formatting (setLenient(false)).
     *
     * @param date The Date object to format.
     * @return The formatted date string (e.g., "2023-10-27"), or an empty string if
     *         the input date is null.
     */
    public static String formatDate(Date date) {
        if (date == null) {
            return "";
        }
        DATE_FORMAT.setLenient(false);
        return DATE_FORMAT.format(date);
    }
}
```

Models\HDBOfficer.java (38)
```java
/**
 * Represents an HDB Officer user in the BTO system
 *
 * @author Jun Yang
 */
package Models;

import Enums.UserRole;
import Enums.MaritalStatus;

public class HDBOfficer extends Applicant {

    /**
     * Constructs a new HDBOfficer object
     *
     * @param nric          The applicant's NRIC. Must not be null
     * @param password      The applicant's password. Must not be null
     * @param name          The applicant's name. Must not be null
     * @param age           The applicant's age
     * @param maritalStatus The applicant's marital status. Must not be null
     * @throws IllegalArgumentException if any required field is null
     */
    public HDBOfficer(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        super(nric, password, name, age, maritalStatus);
    }

    
    /**
     * Gets the user's role
     * 
     * @return The user role enum
     */
    @Override
    public UserRole getRole() {
        return UserRole.HDB_OFFICER;
    }

}
```

Parsers\Dparse.java (38)
```java
/**
 * Utility class for parsing date strings into Date objects.
 * Uses a predefined format ("yyyy-MM-dd").
 *
 * @author Jordon
 */
package Parsers;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Dparse {
    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    /**
     * Parses a date string in "yyyy-MM-dd" format into a Date object.
     * Handles null, empty, or "null" strings by returning null.
     * Prints a warning to stderr if the format is invalid.
     * Uses strict parsing (setLenient(false)).
     *
     * @param dateString The date string to parse.
     * @return A Date object representing the parsed date, or null if parsing fails
     *         or input is invalid.
     */
    public static Date parseDate(String dateString) {
        if (dateString == null || dateString.trim().isEmpty() || dateString.trim().equalsIgnoreCase("null")) {
            return null;
        }
        try {
            DATE_FORMAT.setLenient(false);
            return DATE_FORMAT.parse(dateString.trim());
        } catch (ParseException e) {
            System.err.println("Warning: Invalid date format encountered: '" + dateString + "'. Expected yyyy-MM-dd.");
            return null;
        }
    }
}
```

Models\HDBManager.java (34)
```java
/**
 * Represents an HDB Manager user in the BTO system
 *
 * @author Jun Yang
 */
package Models;

import Enums.MaritalStatus;
import Enums.UserRole;

public class HDBManager extends User {
    /**
     * Constructs a new HDBOfficer object
     *
     * @param nric          The applicant's NRIC. Must not be null
     * @param password      The applicant's password. Must not be null
     * @param name          The applicant's name. Must not be null
     * @param age           The applicant's age
     * @param maritalStatus The applicant's marital status. Must not be null
     * @throws IllegalArgumentException if any required field is null
     */
    public HDBManager(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        super(nric, password, name, age, maritalStatus);
    }

    /**
     * Gets the user's role
     * 
     * @return The user role enum
     */
    @Override
    public UserRole getRole() { return UserRole.HDB_MANAGER; }

}
```

Utils\NricValidator.java (26)
```java
/**
 * Utility class for validating the format of Singapore NRIC (National Registration Identity Card) numbers.
 * Uses a regular expression to check the pattern.
 *
 * @author Jordon
 */
package Utils;

import java.util.regex.Pattern;

public class NricValidator {
    private static final Pattern NRIC_PATTERN = Pattern.compile("^[STFG]\\d{7}[A-Z]$");

    /**
     * Validates if the given string matches the standard NRIC format.
     * The pattern checks for a starting character (S, T, F, G), followed by 7
     * digits, and ending with an uppercase letter.
     *
     * @param nric The NRIC string to validate.
     * @return true if the string matches the NRIC pattern, false otherwise
     *         (including if the input is null).
     */
    public static boolean isValidNric(String nric) {
        return nric == null ? false : NRIC_PATTERN.matcher(nric).matches();
    }
}
```

Enums\ApplicationStatus.java (15)
```java
/**
 * Represents the possible statuses of a BTO (Build-To-Order) application
 *
 * @author Kai Wang
 */
package Enums;

public enum ApplicationStatus {
    PENDING, // Initial state
    SUCCESSFUL, // Manager approved, applicant can book
    UNSUCCESSFUL, // Manager rejected, or withdrawal approved after SUCCESSFUL/BOOKED
    BOOKED, // Officer confirmed booking
    PENDING_WITHDRAWAL, // Applicant requested withdrawal, awaiting Manager action
    WITHDRAWN // Manager approved withdrawal from PENDING state
}
```

Enums\MaritalStatus.java (12)
```java
/**
 * Represents the marital status of a user
 * Used for eligibility checks
 *
 * @author Kai Wang
 */

package Enums;

public enum MaritalStatus {
    SINGLE, MARRIED
}
```

Enums\UserRole.java (11)
```java
/**
 * Represents the different roles a user can have within the BTO system.
 * Determines the user's permissions and available actions.
 *
 * @author Kai Wang
 */
package Enums;

public enum UserRole {
    APPLICANT, HDB_OFFICER, HDB_MANAGER
}
```

Enums\OfficerRegistrationStatus.java (10)
```java
/**
 * Represents the possible statuses of an HDB Officer's registration request for a project
 *
 * @author Kai Wang
 */
package Enums;

public enum OfficerRegistrationStatus {
    PENDING, APPROVED, REJECTED
}
```

